<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>望伊如西の博客</title>
  
  <subtitle>兰芝生于幽谷，不以无人而不芳</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dilidonglong.github.io/"/>
  <updated>2019-05-06T14:57:34.321Z</updated>
  <id>https://dilidonglong.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>英语名词</title>
    <link href="https://dilidonglong.github.io/2019/05/06/%E8%8B%B1%E8%AF%AD%E5%90%8D%E8%AF%8D/"/>
    <id>https://dilidonglong.github.io/2019/05/06/英语名词/</id>
    <published>2019-05-06T14:57:04.000Z</published>
    <updated>2019-05-06T14:57:34.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="英语名词"><a href="#英语名词" class="headerlink" title="英语名词"></a>英语名词</h1><h2 id="1-名词简介"><a href="#1-名词简介" class="headerlink" title="1.名词简介"></a>1.名词简介</h2><p>名词是<strong>人</strong>（people）、<strong>地</strong>（places）、<strong>事</strong>（things）和<strong>想法</strong>（ideas）</p><h3 id="1-1单复数名词singular-and-plural-nouns"><a href="#1-1单复数名词singular-and-plural-nouns" class="headerlink" title="1.1单复数名词singular  and  plural  nouns"></a>1.1单复数名词singular  and  plural  nouns</h3><p>单数名词只包含名词本身，只有一个事物</p><p>复数名词意味着有更多（more），即一个以上的事物</p><p>大部分名词由单数变成复数都是有规律的（即直接在名词后面+s）。但是也有部分名词的变化没有规律</p><h2 id="2-名词种类"><a href="#2-名词种类" class="headerlink" title="2.名词种类"></a>2.名词种类</h2><h3 id="2-1普通名词（common）和专有名词（proper）。"><a href="#2-1普通名词（common）和专有名词（proper）。" class="headerlink" title="2.1普通名词（common）和专有名词（proper）。"></a>2.1普通名词（common）和专有名词（proper）。</h3><p>普通名词在句首时，首字母才大写。而专有名词的首字母是一直大写</p><table><thead><tr><th style="text-align:center">common nouns</th><th style="text-align:center">proper nouns</th></tr></thead><tbody><tr><td style="text-align:center">city</td><td style="text-align:center">Chicago</td></tr><tr><td style="text-align:center">frog</td><td style="text-align:center">Kermit</td></tr><tr><td style="text-align:center">river</td><td style="text-align:center">Nile</td></tr><tr><td style="text-align:center">mountain</td><td style="text-align:center">Kilimanjaro</td></tr></tbody></table><h3 id="2-2具象名词（concrete）和抽象名词（abstract）。"><a href="#2-2具象名词（concrete）和抽象名词（abstract）。" class="headerlink" title="2.2具象名词（concrete）和抽象名词（abstract）。"></a>2.2具象名词（concrete）和抽象名词（abstract）。</h3><p>具象表示看得见摸得着的，而抽象名词则相反，比如一些概念。</p><h2 id="3-不规则名词复数"><a href="#3-不规则名词复数" class="headerlink" title="3.不规则名词复数"></a>3.不规则名词复数</h2><h3 id="3-1-f变为-ves"><a href="#3-1-f变为-ves" class="headerlink" title="3.1-f变为-ves"></a>3.1-f变为-ves</h3><table><thead><tr><th style="text-align:center">singular</th><th style="text-align:center">plural</th></tr></thead><tbody><tr><td style="text-align:center">lea<strong>f</strong></td><td style="text-align:center">lea<strong>ves</strong></td></tr><tr><td style="text-align:center">loa<strong>f</strong></td><td style="text-align:center">loa<strong>ves</strong></td></tr><tr><td style="text-align:center">cal<strong>f</strong></td><td style="text-align:center">cal<strong>ves</strong></td></tr></tbody></table><h3 id="3-2以en结尾的复数名词"><a href="#3-2以en结尾的复数名词" class="headerlink" title="3.2以en结尾的复数名词"></a>3.2以en结尾的复数名词</h3><p>只需要记住一个，<strong>child</strong>要变成<strong>children</strong></p><h3 id="3-3单复数同形"><a href="#3-3单复数同形" class="headerlink" title="3.3单复数同形"></a>3.3单复数同形</h3><p>sheep，fish，bison</p><h3 id="3-4突变体复数"><a href="#3-4突变体复数" class="headerlink" title="3.4突变体复数"></a>3.4突变体复数</h3><table><thead><tr><th style="text-align:center">singular</th><th style="text-align:center">plural</th></tr></thead><tbody><tr><td style="text-align:center">f<strong>oo</strong>t</td><td style="text-align:center">f<strong>ee</strong>t</td></tr><tr><td style="text-align:center">wom<strong>a</strong>n</td><td style="text-align:center">wom<strong>e</strong>n</td></tr><tr><td style="text-align:center">m<strong>a</strong>n</td><td style="text-align:center">m<strong>e</strong>n</td></tr><tr><td style="text-align:center">t<strong>oo</strong>th</td><td style="text-align:center">t<strong>ee</strong>th</td></tr><tr><td style="text-align:center">g<strong>oo</strong>se</td><td style="text-align:center">g<strong>ee</strong>se</td></tr><tr><td style="text-align:center">m<strong>ous</strong>e</td><td style="text-align:center">m<strong>ic</strong>e</td></tr><tr><td style="text-align:center">l<strong>ous</strong>e</td><td style="text-align:center">l<strong>ic</strong>e</td></tr></tbody></table><h3 id="3-5外来词复数"><a href="#3-5外来词复数" class="headerlink" title="3.5外来词复数"></a>3.5外来词复数</h3><table><thead><tr><th style="text-align:center">语言</th><th style="text-align:center">变化</th><th style="text-align:center">单数</th><th style="text-align:center">复数</th><th style="text-align:center">规则变化复数</th></tr></thead><tbody><tr><td style="text-align:center">拉丁语</td><td style="text-align:center">a—ae</td><td style="text-align:center">larv<strong>a</strong></td><td style="text-align:center">larv<strong>ae</strong></td><td style="text-align:center">larva<strong>s</strong></td></tr><tr><td style="text-align:center">拉丁语</td><td style="text-align:center">us—i</td><td style="text-align:center">fung<strong>us</strong></td><td style="text-align:center">fung<strong>i</strong></td><td style="text-align:center">fungus<strong>es</strong></td></tr><tr><td style="text-align:center">拉丁语</td><td style="text-align:center">um—a</td><td style="text-align:center">dat<strong>um</strong></td><td style="text-align:center">dat<strong>a</strong></td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">拉丁语</td><td style="text-align:center">ex—ices</td><td style="text-align:center">ind<strong>ex</strong></td><td style="text-align:center">ind<strong>ices</strong></td><td style="text-align:center">index<strong>es</strong></td></tr><tr><td style="text-align:center">希腊语</td><td style="text-align:center">is—es</td><td style="text-align:center">thes<strong>is</strong></td><td style="text-align:center">thes<strong>es</strong></td><td style="text-align:center">thesis<strong>es</strong></td></tr><tr><td style="text-align:center">希腊语</td><td style="text-align:center">on—a</td><td style="text-align:center">criteci<strong>on</strong></td><td style="text-align:center">criteci<strong>a</strong></td><td style="text-align:center">无</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;英语名词&quot;&gt;&lt;a href=&quot;#英语名词&quot; class=&quot;headerlink&quot; title=&quot;英语名词&quot;&gt;&lt;/a&gt;英语名词&lt;/h1&gt;&lt;h2 id=&quot;1-名词简介&quot;&gt;&lt;a href=&quot;#1-名词简介&quot; class=&quot;headerlink&quot; title=&quot;1.名词简
      
    
    </summary>
    
      <category term="英语" scheme="https://dilidonglong.github.io/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>软考试题3</title>
    <link href="https://dilidonglong.github.io/2019/05/06/%E8%BD%AF%E8%80%83%E8%AF%95%E9%A2%983/"/>
    <id>https://dilidonglong.github.io/2019/05/06/软考试题3/</id>
    <published>2019-05-06T14:56:29.000Z</published>
    <updated>2019-05-06T14:56:55.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软考试题3"><a href="#软考试题3" class="headerlink" title="软考试题3"></a>软考试题3</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A、B是局域网上两个相距1km的站点，A采用同步传输方式以1Mb/s的速率向B发送长度为200，000字节的文件。假定数据帧长为128比特，其中首部为48比特:应答帧为22比特，A在收到B的应答帧后发送下一帧。传送文件花费的时间为（  ）s，有效的数据速率为（  ）Mb/s（传播速率为200m/us）</span><br><span class="line">A.1.6            B.2.4              C.3.2                  D.3.6</span><br><span class="line">A.0.2            B.0.5              C.0.7                  D.0.8</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ol><li><p>数据传输的过程中，可以理解成是寄快递。比如我想给我妈寄一支牙刷，牙刷用纸盒子包着。我妈拿到这个快递后，真正有用的想要的也就只有这个牙刷而已，那个纸盒子不是真正想要的东西。不过纸盒子上会有寄件人和收件人的信息。</p></li><li><p>题干中说的<code>假定数据帧长为128比特，其中首部为48比特</code>，其中首部48比特就类似于是纸盒子。128比特就类似于是被纸盒子包着的牙刷。那此时真正有用的数据部分是多少比特呢？聪明如你，很快就知道了是128-48=80bit。也就是说这80bit就类似于是这个牙刷。</p><hr></li><li><p>现在假设寄的不是牙刷，而是一个需要组装的电脑桌。这个桌子不像牙刷那么好寄，东西太多了，一个纸盒子可能还放不下，要多个纸盒子包着，然后再寄出去。</p></li><li><p>题干中说的200，000字节（即200，000x8=1600，000比特）的文件就类似于是需要组装的电脑桌。每个纸盒子只能放电脑桌部件的一部分，即每个盒子只能放80比特的内容。</p></li><li><p>那么此时需要多少个纸盒子装呢？聪明如你，相信已经知道了。1600 000/80=20 000。</p></li><li><p>一个纸盒子再加上里面的部件，合起来一共是128个比特。那么所有的包裹（纸盒子+电脑桌部件）加起来，占多少个比特呢。就是20 000x128=2560 000比特。</p><hr></li><li><p>快递公司穷，只有一辆车来运包裹，一次还只能运一个。运过去之后，还得等对方说一句我收到了，才能接着发第二个包裹。对方说的那句我收到了，就类似于题干中说的22比特的应答帧。也就是说，我发20 000个包裹过去，居然要回应20 000次我收到了。</p><hr></li><li><p>上述了解完后，可以开始做题了。我们知道如何计算一个数据帧从发出到对方接收所需要时间的公式，即发送时延+传播时延</p></li><li><p><strong>发送时延=数据帧长度/数据速率。把题中数值带入，即128bit/1Mbps=0.000128s。</strong></p></li><li><p><strong>传播时延=两点间距离/光速的三分之二。把题中数值带入，即1000m/（2x10^8）mps=0.000005s</strong></p></li><li><p><strong>所以从发送方发出一个帧到接收方接收，所需要的时间是0.000128+0.000005s=0.000133s</strong></p></li><li><p>我们把包裹发出去，还得等对方说句收到了才能继续发下一个包裹。那么对方说一句收到了，到我们发送方接收到需要多少时间呢？同理可得，<strong>发送时延=数据帧长度/数据速率。把题中数值带入，即22bit/1Mbps=0.000022s。传播时延=两点间距离/光速的三分之二。把题中数值带入，即1000m/（2x10^8）mps=0.000005s</strong>。所以需要的时间是<strong>0.000022s+0.000005s=0.000027s</strong></p><hr></li><li><p>综上，一来一回所需要的时间就是0.000027s+0.000133s=0.00016s</p></li><li><p>这还只是一个包需要的时间，现在要发20 000个包，那总共需要多长时间呢？<strong>对的，0.00016x20 000=3.2s</strong></p><hr></li><li><p>最后一问，问你有效数据速率是多少。你的电脑桌就是真正有效的东西，总共也就1600，000比特，为了发这1600000比特，花了一共3.2s的时间。<strong>所以有效数据速率就是1600000bit/3.2s=500 000bps=0.5Mbps</strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软考试题3&quot;&gt;&lt;a href=&quot;#软考试题3&quot; class=&quot;headerlink&quot; title=&quot;软考试题3&quot;&gt;&lt;/a&gt;软考试题3&lt;/h1&gt;&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问
      
    
    </summary>
    
      <category term="软考" scheme="https://dilidonglong.github.io/categories/%E8%BD%AF%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>软考试题2</title>
    <link href="https://dilidonglong.github.io/2019/05/06/%E8%BD%AF%E8%80%83%E8%AF%95%E9%A2%982/"/>
    <id>https://dilidonglong.github.io/2019/05/06/软考试题2/</id>
    <published>2019-05-06T14:55:13.000Z</published>
    <updated>2019-05-06T14:56:20.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软考试题2"><a href="#软考试题2" class="headerlink" title="软考试题2"></a>软考试题2</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight plain"><figcaption><span>wiki</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">用64K×8的RAM芯片和32K×16的ROM芯片设计一个256K×16的存储器，地址范围为00000H～3FFFFH，其中ROM的地址范围为10000H～1FFFFH，其余为RAM的地址。则地址线为（）根，数据线为（）根；RAM需要（）片，ROM需要（）片。</span><br><span class="line">问题1选项</span><br><span class="line">A 18B 9C 16D 8</span><br><span class="line">问题2选项</span><br><span class="line">A 18            B 9             C 16            D 8</span><br><span class="line">问题3选项</span><br><span class="line">A 1             B 2             C 3             D 6</span><br><span class="line">问题4选项</span><br><span class="line">A 12            B 2             C 9             D 6</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ol><li><p>64Kx8表示什么？</p><p>表示一个芯片的容量。其中64K表示一个芯片内地址块的数目，8表示每个地址块里面存放的比特位数。</p><p>其中，1K=1024，1M=1024K。64K=64x1024=65536，即一个芯片内有65536个地址块</p><p>你可以理解成，有一个大菜地（芯片），你把这个大菜地分成65536个小菜地（地址块）。每个小菜地里面都能种8颗白菜（比特位数）。一个芯片的容量就是整个大菜地里面能种的白菜数量。</p><hr></li><li><p>64Kx8与地址线，数据线的关系？</p><p>64K是一个十进制数，即$2^{16}$。</p><p>地址线传递地址信息。如果用1个比特，可以表示2个地址块（地址块数目是$2^1$），即编号为0的地址块和编号为1的地址块。如果用2个比特，可以表示4个地址块（地址块数目是$2^2$），即编号为00，01，10，11的四个地址块。那么我有16个比特的话，就能表示64K个地址块。<strong>一根地址线就占一个比特位，有16根地址线就表示有16个地址比特位。</strong></p><p>数据线传递数据信息。<strong>一根数据线就占一个比特位，8根数据线就占8个数据比特位。</strong></p><p>这些所谓的线，通过电平的高低变化来表示0或1。只是说不同的线，传递的信息是不同的。地址线传地址信息，数据线传数据信息，控制线传控制信息。这些信息是用0和1表示出来的。</p><hr></li><li><p>一个256K×16的存储器，由64K×8的RAM芯片和32K×16的ROM芯片组成。</p><p>你可以理解成，一个超级大菜地分成2个中型菜地，一个种白菜，一个种辣椒。</p><p>这两个中型菜地又分别由小菜地（RAM和ROM芯片）组成。</p><hr></li><li><p>一个256K×16的存储器，地址范围为00000H～3FFFFH（地址编号为十六进制数）。表示有（3FFFF-00000+1）H个地址块。你想下如果有3个数，编号分别为0~3，是不是一共有4个地址块。用3-0=3是不对的，还得再+1。</p><p>即这个存储器（超级大菜地）有（3FFFF-00000+1）H=40000H个地址块，每个地址块能容纳16个比特位数（种16个农作物）。</p><hr></li><li><p>其中ROM的地址范围为10000H～1FFFFH，这是占了超级大菜地里面的一部分地址块。这部分地址块的数目是多少呢？是（1FFFF-10000+1）H=10000H个。这个十六进制数换成十进制数是64K。</p><p>存储器中ROM芯片给的地址块是64K，每个地址块能容纳16个比特。所以存储器中关于ROM的总容量就是64Kx16。</p><p>由于题目中说了，存储器是由32K×16的ROM芯片组成。ROM总容量已知，每个ROM芯片的容量也已知，此时问你需要多少片<strong>ROM，聪明如你，相信已经知道答案了。（64Kx16）/（32Kx16）=2</strong></p><hr></li><li><p>ROM占了整个存储器的地址块有64K个。存储器共有256K个。那么留下来给RAM的地址块数目即是（256-64）K=192K个。RAM的总容量就是192Kx16。</p><p>知道RAM的总容量，知道每片RAM芯片的容量64K×8，问你需要多少片<strong>RAM。聪明如你，相信已经知道答案了。（192Kx16）/（64Kx8）=6</strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软考试题2&quot;&gt;&lt;a href=&quot;#软考试题2&quot; class=&quot;headerlink&quot; title=&quot;软考试题2&quot;&gt;&lt;/a&gt;软考试题2&lt;/h1&gt;&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问
      
    
    </summary>
    
      <category term="软考" scheme="https://dilidonglong.github.io/categories/%E8%BD%AF%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>tcpdump技巧</title>
    <link href="https://dilidonglong.github.io/2019/04/30/tcpdump%E6%8A%80%E5%B7%A7/"/>
    <id>https://dilidonglong.github.io/2019/04/30/tcpdump技巧/</id>
    <published>2019-04-30T15:44:49.000Z</published>
    <updated>2019-04-30T15:45:16.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tcpdump使用技巧"><a href="#tcpdump使用技巧" class="headerlink" title="tcpdump使用技巧"></a>tcpdump使用技巧</h1><p>1.监视指定网络接口的数据包</p><p>   [root@www ~]# tcpdump -i eth1                          </p><p>2.也可以指定ip,例如截获所有210.27.48.1 的主机收到的和发出的所有的数据包</p><p>   [root@www ~]# tcpdump host 210.27.48.1       </p><p>3.截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信</p><p>   [root@www ~]# tcpdump host 210.27.48.1 and \ (210.27.48.2 or 210.27.48.3 \ )      </p><p>4.获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包</p><p>   [root@www ~]# tcpdump ip host 210.27.48.1 and ! 210.27.48.2     </p><p>5.截获主机webserver发送的所有数据</p><p>   [root@www ~]# tcpdump -i eth0 src host webserver </p><p>6.监视所有送到主机webserver的数据包       </p><p>   [root@www ~]# tcpdump -i eth0 dst host webserver        </p><p>7.获取主机210.27.48.1接收或发出的telnet包</p><p>   [root@www ~]# tcpdump tcp port 23 and host 210.27.48.1       </p><p>8.打印所有源地址或目标地址是本地主机的IP数据包</p><p>   [root@www ~]# tcpdump ip and not net localnet       </p><p> 9.打印长度超过576字节</p><p>   [root@www ~]# tcpdump ip[2:2] &gt; 576     </p><p>10.第一个n表示以IP地址的方式显示主机名，第二个N是以端口数字的形式代替服务名。</p><p>   [root@www ~]# tcpdump -nn </p><hr><p>[root@www ~]# tcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap<br>(1)tcp: ip icmp arp rarp 和 tcp、udp、icmp这些选项等都要放到第一个参数的位置，用来过滤数据报的类型<br>(2)-i eth1 : 只抓经过接口eth1的包<br>(3)-t : 不显示时间戳<br>(4)-s 0 : 抓取数据包时默认抓取长度为68字节。加上-S 0 后可以抓到完整的数据包<br>(5)-c 100 : 只抓取100个数据包<br>(6)dst port ! 22 : 不抓取目标端口是22的数据包<br>(7)src net 192.168.1.0/24 : 数据包的源网络地址为192.168.1.0/24<br>(8)-w ./target.cap : 保存成cap文件，方便用ethereal(即wireshark)分析</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tcpdump使用技巧&quot;&gt;&lt;a href=&quot;#tcpdump使用技巧&quot; class=&quot;headerlink&quot; title=&quot;tcpdump使用技巧&quot;&gt;&lt;/a&gt;tcpdump使用技巧&lt;/h1&gt;&lt;p&gt;1.监视指定网络接口的数据包&lt;/p&gt;
&lt;p&gt;   [root@www
      
    
    </summary>
    
      <category term="linux" scheme="https://dilidonglong.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>wireshark技巧</title>
    <link href="https://dilidonglong.github.io/2019/04/30/wireshark%E6%8A%80%E5%B7%A7/"/>
    <id>https://dilidonglong.github.io/2019/04/30/wireshark技巧/</id>
    <published>2019-04-30T15:40:03.000Z</published>
    <updated>2019-04-30T15:42:53.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wireshark技巧"><a href="#wireshark技巧" class="headerlink" title="wireshark技巧"></a>wireshark技巧</h1><blockquote><p>资料来源：</p><p><a href="https://community.emc.com/go/chinese" target="_blank" rel="noopener">1.EMC中文支持论坛</a></p><p><a href="https://www.dell.com/community/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%AE%A8%E8%AE%BA%E5%8C%BA/%E5%A6%82%E6%9E%9C%E7%9C%8B%E4%BA%86%E8%BF%99%E4%B8%AA%E4%BD%A0%E8%BF%98%E6%98%AF%E4%B8%8D%E4%BC%9A%E7%94%A8Wireshark-%E9%82%A3%E5%B0%B1%E6%9D%A5%E6%89%BE%E6%88%91%E5%90%A7-8%E6%9C%886%E6%97%A5%E5%AE%8C%E7%BB%93/td-p/7007033/page/5" target="_blank" rel="noopener">2.如果看了这个你还是不会用Wireshark-那就来找我吧-8月6日完结</a></p><p><a href="http://linux.51yip.com/search/tcpdump" target="_blank" rel="noopener">3.Linux命令手册-tcpdump</a></p><p><a href="https://chegva.com/3019.html" target="_blank" rel="noopener">4.Linux上使用wireshark(tshark)抓包分析</a></p><p><a href="https://chegva.com/2473.html" target="_blank" rel="noopener">5.tcpdump使用技巧</a></p></blockquote><h2 id="1-抓包前设置过滤条件（捕捉过滤器）"><a href="#1-抓包前设置过滤条件（捕捉过滤器）" class="headerlink" title="1.抓包前设置过滤条件（捕捉过滤器）"></a>1.抓包前设置过滤条件（捕捉过滤器）</h2><p><strong>尽量避免使用抓包过滤。即便多看几个报文，也比漏看一个报文要好。</strong>当你抓取了大量报文的时候，用显示过滤（过滤选项也更多）来重点查看某一数据流。</p><h3 id="1-1-抓取指定IP地址的数据流："><a href="#1-1-抓取指定IP地址的数据流：" class="headerlink" title="1.1 抓取指定IP地址的数据流："></a>1.1 抓取指定IP地址的数据流：</h3><ol><li>host 10.3.1.1：抓取发到/来自10.3.1.1的数据流</li><li>host 2406:da00:ff00::6b16:f02d：抓取发到/来自IPv6地址2406:da00:ff00::6b16:f02d的数据流</li><li>not host 10.3.1.1：抓取除了发到/来自10.3.1.1以外的所有数据流</li><li>src host 10.3.1.1：抓取来自10.3.1.1的数据流</li><li>dst host 10.3.1.1：抓取发到10.3.1.1的数据流</li><li>host 10.3.1.1 or 10.3.1.2：抓取发到/来自10.3.1.1，以及与之通讯的所有数据流，与10.3.1.2，以及与之通讯的所有数据流</li><li>host <a href="http://www.espn.com：抓取发到/来自所有解析为www.espn.com的IP地址的数据流" target="_blank" rel="noopener">www.espn.com：抓取发到/来自所有解析为www.espn.com的IP地址的数据流</a></li></ol><h3 id="1-2-抓取指定IP地址范围的数据流"><a href="#1-2-抓取指定IP地址范围的数据流" class="headerlink" title="1.2 抓取指定IP地址范围的数据流:"></a>1.2 抓取指定IP地址范围的数据流:</h3><ol><li>net 10.3.0.0/16：抓取网络10.3.0.0上发到/来自所有主机的数据流(16表示长度)</li><li>net 10.3.0.0 mask 255.255.0.0：与之前的过滤结果相同</li><li>ip6 net 2406:da00:ff00::/64：抓取网络2406:da00:ff00:0000(IPv6)上发到/来自所有主机的数据流</li><li>not dst net 10.3.0.0/16：抓取除了发到以10.3开头的IP地址以外的所有数据流</li><li>not src net 10.3.0.0/16：抓取除了来自以10.3开头的IP地址以外的所有数据流</li><li>ip proto &lt; protocol code &gt;：抓取ip协议字段等于&lt; protocol code &gt;值的报文。如TCP(code 6), UDP(code 17), ICMP(code 1)。</li><li>ip[2:2]==&lt; number &gt;：ip报文大小</li><li>ip[8]==&lt; number &gt;：TTL(Time to Live)值</li><li>ip[9]==&lt; number &gt;：协议值</li><li>icmp[icmptype]==&lt; identifier &gt;: 抓取 ICMP代码等于identifier的ICMP报文, 如icmp-echo 以及 icmp-request。</li></ol><p>方括号中第一个数字表示从<u><strong>协议头</strong></u>开始的偏移量，第二个数字表示需要观察多少位。</p><p><img src="/2019/04/30/wireshark技巧/1.png" alt="image004.png"></p><h3 id="1-3-抓取发到广播或多播地址的数据流"><a href="#1-3-抓取发到广播或多播地址的数据流" class="headerlink" title="1.3 抓取发到广播或多播地址的数据流:"></a>1.3 抓取发到广播或多播地址的数据流:</h3><p>只需侦听广播或多播数据流，就可以掌握网络上主机的许多信息。</p><ol><li>ip broadcast：抓取广播报文</li><li>ip multicast：抓取多播报文</li><li>dst host ff02::1：抓取到IPv6多播地址所有主机的数据流</li><li>dst host ff02::2：抓取到IPv6多播地址所有路由器的数据流</li></ol><h3 id="1-4-抓取基于MAC地址的数据流"><a href="#1-4-抓取基于MAC地址的数据流" class="headerlink" title="1.4 抓取基于MAC地址的数据流:"></a>1.4 抓取基于MAC地址的数据流:</h3><p>当你需要抓取发到/来自某一主机的IPv4或IPv6数据流，可创建基于主机MAC地址的抓包过滤条件。</p><p>应用MAC地址时，需确保与目标主机处于同一网段。</p><ol><li>ether host 00:08:15:00:08:15：抓取发到/来自00:08:15:00:08:15的数据流</li><li>ether src 02:0A:42:23:41:AC：抓取来自02:0A:42:23:41:AC的数据流</li><li>ether dst 02:0A:42:23:41:AC：抓取发到02:0A:42:23:41:AC的数据流</li><li>not ether host 00:08:15:00:08:15：抓取除了发到/来自00:08:15:00:08:15以外的所有数据流</li><li>ether broadcast或ether dst ff:ff:ff:ff:ff:ff：抓取广播报文</li><li>ether multicast：多播报文</li><li>抓取指定以太网类型的报文：ether proto 0800</li><li>抓取指定VLAN：vlan &lt; vlan number &gt;</li><li>抓取指定几个VLAN：vlan &lt; vlan number &gt; and vlan &lt; vlan number &gt;</li></ol><h3 id="1-5-抓取基于指定应用的数据流"><a href="#1-5-抓取基于指定应用的数据流" class="headerlink" title="1.5 抓取基于指定应用的数据流:"></a>1.5 抓取基于指定应用的数据流:</h3><p>你可能需要查看基于一个或几个应用的数据流。抓包过滤器语法无法识别应用名，因此需要根据端口号来定义应用。通过目标应用的TCP或UDP端口号，将不相关的报文过滤掉。</p><ol><li>port 53：抓取发到/来自端口53的UDP/TCP数据流（典型是DNS数据流）</li><li>not port 53：抓取除了发到/来自端口53以外的UDP/TCP数据流</li><li>port 80：抓取发到/来自端口80的UDP/TCP数据流（典型是HTTP数据流）</li><li>udp port 67：抓取发到/来自端口67的UDP数据流（典型是DHCP据流）</li><li>tcp port 21：抓取发到/来自端口21的TCP数据流（典型是FTP命令通道）</li><li>portrange 1-80：抓取发到/来自端口1-80的所有UDP/TCP数据流</li><li>tcp portrange 1-80：抓取发到/来自端口1-80的所有TCP数据流</li></ol><h3 id="1-6-抓取结合端口的数据流"><a href="#1-6-抓取结合端口的数据流" class="headerlink" title="1.6 抓取结合端口的数据流:"></a>1.6 抓取结合端口的数据流:</h3><p>当你需要抓取多个不连续端口号的数据流，将它们通过逻辑符号连接起来，如下图所示：</p><ol><li>port 20 or port 21：抓取发到/来自端口20或21的UDP/TCP数据流（典型是FTP数据和命令端口）</li><li>host 10.3.1.1 and port 80：抓取发到/来自10.3.1.1端口80的数据流</li><li>host 10.3.1.1 and not port 80：抓取发到/来自10.3.1.1除了端口80以外的数据流</li><li>udp src port 68 and udp dst port 67：抓取从端口68到端口67的所有UDP数据流（典型是从DHCP客户端到DHCP服务器）</li><li>udp src port 67 and udp dst port 68：抓取从端口67到端口68的所有UDP数据流（典型是从DHCP服务器到DHCP客户端）</li><li>抓取TCP连接的开始（SYN）和结束（FIN）报文，配置tcp[tcpflags] &amp; (tcp-syn|tcp-fin)!=0</li><li>抓取所有RST(Reset)标志位为1的TCP报文，配置tcp[tcpflags] &amp; (tcp-rst)!=0</li><li>less &lt; length &gt;：抓取小于等于某一长度的报文，等同于len &lt;=&lt; length &gt;</li><li>greater &lt; length &gt;：抓取大于等于某一长度的报文，等同于len &gt;=&lt; length &gt;</li></ol><p>SYN: 建立连接的信号</p><p>FIN: 关闭连接的信号</p><p>ACK: 确认接收数据的信号</p><p>RST: 立即关闭连接的信号</p><p>PSH: 推信号，尽快将数据转由应用处理</p><ul><li>tcp[13] &amp; 0x00 = 0: No flags set (null scan)</li><li>tcp[13] &amp; 0x01 = 1: FIN set and ACK not set</li><li>tcp[13] &amp; 0x03 = 3: SYN set and FIN set</li><li>tcp[13] &amp; 0x05 = 5: RST set and FIN set</li><li>tcp[13] &amp; 0x06 = 6: SYN set and RST set</li><li>tcp[13] &amp; 0x08 = 8: PSH set and ACK not set</li><li>tcp[13]是从<u><strong>协议头</strong></u>开始的偏移量，0,1,3,5,6,8是标识位。</li></ul><p><img src="/2019/04/30/wireshark技巧/2.png" alt="image005.png"></p><hr><h2 id="2-抓包后设置过滤条件（显示过滤器）"><a href="#2-抓包后设置过滤条件（显示过滤器）" class="headerlink" title="2.抓包后设置过滤条件（显示过滤器）"></a>2.抓包后设置过滤条件（显示过滤器）</h2><h3 id="2-1-协议过滤器"><a href="#2-1-协议过滤器" class="headerlink" title="2.1 协议过滤器"></a>2.1 协议过滤器</h3><ol><li>arp：显示所有包括ARP请求和回复在内的所有ARP数据流。</li><li>ip：显示内含IPv4头在内的（如ICMP目的地址不可达报文，在ICMP报文头之后返回到来方向的IPv4头）IP数据流。</li><li>ipv6：显示所有IPv6数据流，包括内含IPv6报文头的IPv4报文，如6to4，Teredo，以及ISATAP数据流。</li><li>tcp：显示所有基于TCP的数据流。</li></ol><h3 id="2-2-应用过滤器"><a href="#2-2-应用过滤器" class="headerlink" title="2.2 应用过滤器"></a>2.2 应用过滤器</h3><ol><li>bootp：显示所有DHCP数据流（基于BOOTP）。</li><li>dns：显示包括TCP区域传输以及基于标准UDP的DNS请求和回复在内的所有DNS数据流。</li><li>tftp：显示所有TFTP（Trivial File Transfer Protocol）数据流。</li><li>http：显示所有HTTP命令，回复以及数据传输报文，但不显示TCP握手报文，TCP ACK报文以及TCP结束报文。</li><li>icmp：显示所有ICMP报文。</li></ol><h3 id="2-3-字符过滤器"><a href="#2-3-字符过滤器" class="headerlink" title="2.3 字符过滤器"></a>2.3 字符过滤器</h3><ol><li>tcp.analysis.flags：显示所有包含TCP分析标识的所有报文，包括报文丢失，重传，或零窗口标识。</li><li>tcp.analysis.zero_window：显示含有表明发送方的接收缓存用完标识的报文。</li></ol><h3 id="2-4-域过滤器"><a href="#2-4-域过滤器" class="headerlink" title="2.4 域过滤器"></a>2.4 域过滤器</h3><ol><li>boot.option.hostname：显示所有包含主机名的DHCP数据流（DHCP基于BOOTP）。</li><li>http:host：显示所有包含HTTP主机名字段的所有HTTP报文。此报文是客户端向网络服务器发送请求时发出的。</li><li>ftp.request.command：显示所有包含命令的FTP数据流，比如USER，PASS，或RETR命令。</li></ol><h3 id="2-5-显示过滤器的比较运算符"><a href="#2-5-显示过滤器的比较运算符" class="headerlink" title="2.5 显示过滤器的比较运算符"></a>2.5 显示过滤器的比较运算符</h3><ol><li><p>==或eq</p><p>例如：ip.src == 10.2.2.2</p><p>显示所有源地址为10.2.2.2的IPv4数据流</p></li><li><p>！=或ne</p><p>例如：tcp.srcport != 80</p><p>显示源端口除了80以外的所有TCP数据流</p></li><li><p>gt 或 &gt;</p><p>例如：frame.time_relative &gt; 1</p><p>显示距前一个报文到达时间相差1秒的报文</p></li><li><p>&lt;或lt</p><p>例如：tcp.window_size &lt; 1460</p><p>显示当TCP接收窗口小于1460字节时的报文</p></li><li><p>ge 或 &gt;=</p><p>例如：dns.count.answers &gt;= 10</p><p>显示包含10个以上answer的DNS响应报文</p></li><li><p>&lt;=或le</p><p>例如：ip.ttl &lt;= 10</p><p>显示IP报文中Time to Live字段小于等于10的报文</p></li><li><p>contains</p><p>例如：http contains “GET”</p><p>显示所有HTTP客户端发送给HTTP服务器的GET请求</p></li></ol><p>对于基于TCP应用的过滤条件采用比较运算符。例如，如果想看端口80上面的HTTP数据流，使用HTTP.port==80。</p><p>小贴士：</p><p>运算符两边不用留空格。ip.src == 10.2.2.2与ip.src==10.2.2.2的效果是相同的。</p><h3 id="2-6-举例应用"><a href="#2-6-举例应用" class="headerlink" title="2.6 举例应用"></a>2.6 举例应用</h3><h4 id="2-6-1-按照某一IP地址或主机过滤报文："><a href="#2-6-1-按照某一IP地址或主机过滤报文：" class="headerlink" title="2.6.1 按照某一IP地址或主机过滤报文："></a>2.6.1 按照某一IP地址或主机过滤报文：</h4><ul><li><p>例如：ip.addr==10.3.1.1</p><p>显示在IP源地址字段或IP目的地址字段包含10.3.1.1的帧。</p><hr></li><li><p>例如：！ip.addr==10.3.1.1</p><p>显示除了在IP源地址字段或IP目的地址字段包含10.3.1.1以外的帧。</p><hr></li><li><p>例如：ipv6.addr==2406:da00:ff00::6b16:f02d</p><p>显示以2406:da00:ff00::6b16:f02d为源地址或目的地址的帧。</p><hr></li><li><p>例如：ip.src==10.3.1.1</p><p>显示所有来自10.3.1.1的数据流。</p><hr></li><li><p>例如：ip.dst==10.3.1.1</p><p>显示所有发往10.3.1.1的数据流</p><hr></li><li><p>例如：ip.host==<a href="http://www.wireshark.org" target="_blank" rel="noopener">www.wireshark.org</a></p><p>显示所有解析为<a href="http://www.wireshark.org的IP" target="_blank" rel="noopener">www.wireshark.org的IP</a></p><hr></li></ul><h4 id="2-6-2-按照某一IP地址范围过滤报文："><a href="#2-6-2-按照某一IP地址范围过滤报文：" class="headerlink" title="2.6.2 按照某一IP地址范围过滤报文："></a>2.6.2 按照某一IP地址范围过滤报文：</h4><p>可以使用&gt;或&lt;比较运算符或逻辑运算符&amp;&amp;查找某一地址范围内的报文。</p><ul><li><p>例如：ip.addr&gt;10.3.0.1&amp;&amp;ip.addr&lt;10.3.0.5</p><p>显示来自或发往10.3.0.2，10.3.0.3，10.3.0.4的数据流。</p><hr></li><li><p>例如：(ip.addr&gt;=10.3.0.1&amp;&amp;ip.addr&lt;=10.3.0.6)&amp;&amp;!ip.addr==10.3.0.3</p><p>显示来自或发往10.3.0.1，10.3.0.2，10.3.0.4，10.3.0.5，10.3.0.6的数据流，10.3.0.3排除在外。</p><hr></li><li><p>例如：ipv6.addr&gt;=fe80::&amp;&amp;ipv6.addr&lt;fec0::</p><p>显示IPv6地址从0xfe80到0xfec0开头的数据流。</p><hr></li></ul><h4 id="2-6-3-按照某一IP子网过滤报文："><a href="#2-6-3-按照某一IP子网过滤报文：" class="headerlink" title="2.6.3 按照某一IP子网过滤报文："></a>2.6.3 按照某一IP子网过滤报文：</h4><p>可以通过ip.addr字段名定义一个子网。这种格式使用IP地址后跟斜杠以及一个后缀，表明IP地址中定义的网络部分的比特数。</p><ul><li><p>例如：ip.addr==10.3.0.0/16</p><p>显示在IP源地址或目的地址字段以10.3开头的数据流。</p><hr></li><li><p>例如：ip.addr == 10.3.0.0/16 &amp;&amp; ！ip.addr==10.3.1.1</p><p>显示除了10.3.1.1以外，在IP源地址或目的地址字段以10.3开头的数据流。</p><hr></li><li><p>例如：!ip.addr == 10.3.0.0/16 &amp;&amp; !ip.addr==10.2.0.0/16</p><p>显示所有数据流，除了在IP源地址或目的地址字段以10.3和10.2开头的数据流</p><hr></li></ul><blockquote><p>注意：</p><p>错误的用法导致不work：</p><hr><p>错误：ip.addr != 10.2.2.2</p><p>显示在IP源地址或IP目的地址不包含10.2.2.2的报文。只要在源或目的IP地址不为10.2.2.2，报文就会被显示出来。这时隐含的或会导致实际上并未过滤任何报文。</p><p>正确：！ip.addr == 10.2.2.2</p><p>显示IP源地址和IP目的地址都不包含10.2.2.2的报文。</p><hr><p>错误：!tcp.flags.syn==1</p><p>显示所有不含TCP SYN bit设置为1的报文。其他协议报文，必须UDP和ARP报文也符合这一过滤条件，因为它们的TCP SYN bit没有设置为1。</p><p>正确：tcp.flags.syn！=1</p><p>只显示包含SYN设置为0的TCP报文。</p><hr></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;wireshark技巧&quot;&gt;&lt;a href=&quot;#wireshark技巧&quot; class=&quot;headerlink&quot; title=&quot;wireshark技巧&quot;&gt;&lt;/a&gt;wireshark技巧&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;资料来源：&lt;/p&gt;
&lt;p&gt;&lt;a href=
      
    
    </summary>
    
      <category term="小技巧" scheme="https://dilidonglong.github.io/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>文件系统的简单操作</title>
    <link href="https://dilidonglong.github.io/2019/04/30/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"/>
    <id>https://dilidonglong.github.io/2019/04/30/文件系统的简单操作/</id>
    <published>2019-04-30T15:34:18.000Z</published>
    <updated>2019-04-30T15:34:45.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件系统的简单操作"><a href="#文件系统的简单操作" class="headerlink" title="文件系统的简单操作"></a>文件系统的简单操作</h1><h2 id="1-df和du命令"><a href="#1-df和du命令" class="headerlink" title="1.df和du命令"></a>1.df和du命令</h2><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>列出文件系统的整体磁盘使用量，df读取的数据几乎针对一整个文件系统，因为读取范围是<strong>超级区块</strong>内的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@vultr ~]<span class="comment"># df</span></span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">devtmpfs          214728       0    214728   0% /dev</span><br><span class="line">tmpfs             246392       0    246392   0% /dev/shm</span><br><span class="line">/dev/vda1       10291200 2231176   7519412  23% /</span><br><span class="line"><span class="comment"># Filesystem表示文件系统在哪个磁盘分区</span></span><br><span class="line"><span class="comment"># 1K-blocks表示单位为1k，可以利用-h来变成人们易于理解的单位格式</span></span><br><span class="line"><span class="comment"># Mounted on表示挂载点</span></span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">[root@vultr ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs        210M     0  210M   0% /dev</span><br><span class="line">tmpfs           241M     0  241M   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1       9.9G  2.2G  7.2G  23% /</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">[root@vultr ~]<span class="comment"># df -Th</span></span><br><span class="line">Filesystem     Type      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs       devtmpfs  210M     0  210M   0% /dev</span><br><span class="line">tmpfs          tmpfs     241M     0  241M   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1      ext4      9.9G  2.2G  7.2G  23% /</span><br><span class="line"><span class="comment"># Type表示文件系统类型</span></span><br></pre></td></tr></table></figure><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p>du不同于df，du会在整个文件系统内去<strong>查找所有的文件数据</strong></p><h2 id="2-硬件链接和软链接（符号链接）"><a href="#2-硬件链接和软链接（符号链接）" class="headerlink" title="2.硬件链接和软链接（符号链接）"></a>2.硬件链接和软链接（符号链接）</h2><h3 id="2-1硬件链接"><a href="#2-1硬件链接" class="headerlink" title="2.1硬件链接"></a>2.1硬件链接</h3><p>目录的数据区块下新增一条文件名链接到某个inode号码的<strong>关联记录</strong>。即多个文件名对应到同一个inode号码。</p><p>硬链接的限制：1.不能跨文件系统。2.不能连接目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@vultr tmp]<span class="comment"># ll -i</span></span><br><span class="line">total 4</span><br><span class="line"> 11618 -rw-r--r-- 1 root root    0 Apr 18 06:16 <span class="built_in">test</span></span><br><span class="line">[root@vultr tmp]<span class="comment"># </span></span><br><span class="line">[root@vultr tmp]<span class="comment"># ln test zhang</span></span><br><span class="line">[root@vultr tmp]<span class="comment"># ll -i</span></span><br><span class="line">total 4</span><br><span class="line"> 11618 -rw-r--r-- 2 root root    0 Apr 18 06:16 <span class="built_in">test</span></span><br><span class="line"> 11618 -rw-r--r-- 2 root root    0 Apr 18 06:16 zhang</span><br></pre></td></tr></table></figure><h3 id="2-2符号链接"><a href="#2-2符号链接" class="headerlink" title="2.2符号链接"></a>2.2符号链接</h3><p>符号链接就是建立一个独立的<strong>文件</strong>，而这个文件会让数据的读取指向它连接的那个文件的文件名</p><p>当源文件被删除后，符号链接的文件就会打不开。类似于是Windows下的快捷方式</p><p>需要注意的是，通过符号链接进入到了某个目录或是打开了某个文件。操作的对象实际上还是原始文件。所以你在符号链接里面打开了东西，进行了操作，那原始文件也会发生改变。如果你在符号链接里面把内容删除了，相当于原始文件的实际内容也删除了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@vultr tmp]<span class="comment"># ln -s test zhangshuaiyang            加上-s就是符号链接，不加是硬链接</span></span><br><span class="line">[root@vultr tmp]<span class="comment"># ll -i</span></span><br><span class="line">total 4</span><br><span class="line"> 11618 -rw-r--r-- 2 root root    0 Apr 18 06:16 <span class="built_in">test</span></span><br><span class="line"> 11618 -rw-r--r-- 2 root root    0 Apr 18 06:16 zhang</span><br><span class="line"> 23193 lrwxrwxrwx 1 root root    4 Apr 18 06:43 zhangshuaiyang -&gt; <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h2 id="3-磁盘分区、格式化、检验及挂载"><a href="#3-磁盘分区、格式化、检验及挂载" class="headerlink" title="3.磁盘分区、格式化、检验及挂载"></a>3.磁盘分区、格式化、检验及挂载</h2><p>如果想在系统里面新增一块硬盘，操作过程如下：</p><ol><li>对磁盘进行划分，进行磁盘分区</li><li>对分区进行格式化，以建立文件系统</li><li>对文件系统进行检验（可选）</li><li>在linux系统上，建立一个挂载点（目录），把该文件系统挂载上来</li></ol><h3 id="3-1查看磁盘分区状态"><a href="#3-1查看磁盘分区状态" class="headerlink" title="3.1查看磁盘分区状态"></a>3.1查看磁盘分区状态</h3><p><strong>lsblk</strong>（list block device）显示出所有存储设备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@vultr tmp]<span class="comment"># lsblk</span></span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0     11:0    1 1024M  0 rom  </span><br><span class="line">vda    253:0    0   10G  0 disk </span><br><span class="line">└─vda1 253:1    0   10G  0 part /</span><br><span class="line"><span class="comment">#name表示设备文件名，会省略/dev等前面的目录；disk表示一整块磁盘；part表示分区</span></span><br><span class="line"><span class="comment">#在vda这个磁盘下，有一个分区vda1</span></span><br><span class="line">----------------------------------------------------------</span><br><span class="line">[root@vultr tmp]<span class="comment"># lsblk -ipf                 通过-f选项可以列出UUID</span></span><br><span class="line">NAME        FSTYPE LABEL UUID                                 MOUNTPOINT</span><br><span class="line">/dev/sr0                                                      </span><br><span class="line">/dev/vda                                                      </span><br><span class="line">`-/dev/vda1 ext4         19c82273-828c-4d85-bc4e-6fc269acc524 /</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">[root@vultr tmp]<span class="comment"># blkid                       通过blkid也可以显示出UUID</span></span><br><span class="line">/dev/vda1: UUID=<span class="string">"19c82273-828c-4d85-bc4e-6fc269acc524"</span> TYPE=<span class="string">"ext4"</span></span><br></pre></td></tr></table></figure><p><strong>parted</strong>列出磁盘的分区表类型及分区信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@vultr tmp]<span class="comment"># parted /dev/vda print</span></span><br><span class="line">Model: Virtio Block Device (virtblk)</span><br><span class="line">Disk /dev/vda: 10.7GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: msdos                     <span class="comment">#分区表格式，比如MBR/GPT，这里显示的是msdos</span></span><br><span class="line">Disk Flags: </span><br><span class="line">   <span class="comment">#下面内容是分区数据</span></span><br><span class="line">Number  Start   End     Size    Type     File system  Flags</span><br><span class="line"> 1      1049kB  10.7GB  10.7GB  primary  ext4         boot</span><br></pre></td></tr></table></figure><h3 id="3-2磁盘分区"><a href="#3-2磁盘分区" class="headerlink" title="3.2磁盘分区"></a>3.2磁盘分区</h3><p>MBR分区表使用fdisk工具进行，GPT分区表使用gdisk工具进行。</p><h3 id="3-3磁盘格式化"><a href="#3-3磁盘格式化" class="headerlink" title="3.3磁盘格式化"></a>3.3磁盘格式化</h3><p>所谓格式化，其实是指在分区上创建文件系统。使用的命令是mkfs（make filesystem）</p><p>如果我们要创建的文件系统是xfs。那么命令的写法就是mkfs.xfs。例如<code>mkfs.xfs /dev/vda4</code>，表示在/dev/vda4这个分区上建立一个xfs文件系统。</p><p>如果是创建ext4文件系统。则命令写法是mkfs.ext4。只是xfs的文件系统建立起来速度更快。</p><p>想知道能创建哪些文件系统。只要再命令行中输入<code>mkfs[tab][tab]</code>，就能看到了。</p><h3 id="3-4文件系统的挂载"><a href="#3-4文件系统的挂载" class="headerlink" title="3.4文件系统的挂载"></a>3.4文件系统的挂载</h3><p>注意点：</p><ol><li>单一文件系统不要被重复挂载到不同的挂载点中</li><li>单一目录不要重复挂载多个文件系统</li><li>作为挂载点的目录，最好是空目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@vultr tmp]<span class="comment"># blkid                       </span></span><br><span class="line">/dev/vda1: UUID=<span class="string">"19c82273-828c-4d85-bc4e-6fc269acc524"</span> TYPE=<span class="string">"ext4"</span> </span><br><span class="line"></span><br><span class="line">[root@vultr tmp]<span class="comment"># mount UUID="19c82273-828c-4d85-bc4e-6fc269acc524" /data/ext4</span></span><br><span class="line">其中UUID表示文件系统的ID。/data/ext4表示挂载点。也就是说把这个文件系统挂载在/data/ext4目录下。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件系统的简单操作&quot;&gt;&lt;a href=&quot;#文件系统的简单操作&quot; class=&quot;headerlink&quot; title=&quot;文件系统的简单操作&quot;&gt;&lt;/a&gt;文件系统的简单操作&lt;/h1&gt;&lt;h2 id=&quot;1-df和du命令&quot;&gt;&lt;a href=&quot;#1-df和du命令&quot; class
      
    
    </summary>
    
      <category term="linux" scheme="https://dilidonglong.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>文件系统</title>
    <link href="https://dilidonglong.github.io/2019/04/30/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://dilidonglong.github.io/2019/04/30/文件系统/</id>
    <published>2019-04-30T15:33:00.000Z</published>
    <updated>2019-04-30T15:33:54.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p><strong>柱面</strong>通常是<strong>分区</strong>及<strong>文件系统</strong>的最小单位。当然如果使用GPT格式的分区表，最小单位可以为<strong>扇区</strong></p><p>磁盘分区完后，要进行<strong>格式化</strong>，使之成为操作系统能用的<strong>文件系统</strong></p><p>文件（或目录）包含<strong>属性</strong>（比如文件权限，文件属性）及<strong>内容</strong></p><table><thead><tr><th style="text-align:center">权限与属性</th><th style="text-align:center">实际数据</th></tr></thead><tbody><tr><td style="text-align:center">inode表</td><td style="text-align:center">数据区块</td></tr></tbody></table><p>区块有放置<strong>inode表</strong>的区块，有放置<strong>数据</strong>的数据区块，以及记录<strong>整个文件系统整体信息</strong>的超级区块</p><blockquote><p>超级区块：记录inode和数据区块总量、使用量、剩余量及文件系统格式等</p><p>inode：记录文件属性，一个文件占一个inode，同时记录文件对应数据所放置的区块号码</p><p>数据区块：记录实际内容，当一个区块占不下的时候，就会占用多个数据区块</p></blockquote><p><strong>索引式文件系统</strong>，包含了inode。通过inode，我们可以数据存放在哪些数据区块里面，所以可以一次性全部提取出来。该方式性能比较好，比如linux的ext2文件系统</p><p>再比如u盘一般使用FAT文件系统，这种就不是索引式文件系统。它没有inode，所以无法把数据一次性全提取出来。每个区块号码都记录在前一个区块里面，所以提取的时候得一个连着一个提取。</p><p><strong>碎片整理</strong>，在非索引式文件系统里面，由于有时候数据写入的区块太过于分散，所以读取的时候性能会很差，通过磁盘碎片整理，可以把同一个文件的区块集合在一起，这样读取起来就比较容易。</p><h2 id="1-ext2文件系统"><a href="#1-ext2文件系统" class="headerlink" title="1.ext2文件系统"></a>1.ext2文件系统</h2><p>在分区上进行格式化的时候，就已经规划好了<strong>inode</strong>和<strong>数据区块</strong></p><p>把放置inode的区块和数据区块全部都放一起，会导致很难管理</p><p>所以在ext2的文件系统上，会弄出多个<strong>区块群组</strong>，每个区块群组都有自己的<strong>inode</strong>，<strong>数据区块</strong>和<strong>超级区块</strong></p><p>在<strong>文件系统</strong>最前面有个启动扇区，里面可以存放<strong>启动引导程序</strong>。（注：或是想到之前的磁盘分区，分区的第一个扇区用来放MBR，MBR中的446字节来存放启动引导程序）</p><p>这种设计可以把引导启动程序放在<strong>不同文件系统</strong>的最前端，而不必把程序全都放在整个磁盘唯一的MBR下。</p><h3 id="1-1数据区块"><a href="#1-1数据区块" class="headerlink" title="1.1数据区块"></a>1.1数据区块</h3><p>数据区块用来放置文件数据。ext2文件系统支持的区块大小有1k，2k及4k共3种。</p><p>每个区块都有编号，方便inode表记录。</p><p>数据放在数据区块里面，如果数据的大小要小于区块的容量的话，就会造成浪费。</p><h3 id="1-2inode表"><a href="#1-2inode表" class="headerlink" title="1.2inode表"></a>1.2inode表</h3><p>inode表记录如下内容</p><blockquote><ul><li><strong>该文件的读写属性（读、写、执行）</strong></li><li><strong>文件所有者及用户组</strong></li><li>文件大小</li><li>文件建立或状态改变时间</li><li>最近一次读取时间</li><li>最近修改时间</li><li>定义文件特征标识</li><li><strong>文件真正内容指向</strong></li></ul></blockquote><p>inode表的数量和大小在格式化的时候就确定好了</p><blockquote><ul><li>每个inode表大小为128B（其中4B来记录一个数据区块的位置编号，一共能记录12个）</li><li>每个文件仅占用一个inode表</li><li>文件系统能建立的文件数量和inode数量有关</li><li>系统读取文件先找到inode表，分析文件记录用户及权限是否符合，如果符合最后才去找数据区块读取</li></ul></blockquote><h3 id="1-3超级区块"><a href="#1-3超级区块" class="headerlink" title="1.3超级区块"></a>1.3超级区块</h3><p>没有超级区块，就没有文件系统，它记录整个文件系统相关信息。</p><blockquote><ul><li>数据区块与inode的总量</li><li>未使用与已经使用的inode与数据区块的数量</li><li>数据区块与inode的大小</li><li>文件系统的挂载时间、最近一次写入数据时间等文件系统相关信息</li><li>一个有效位数值，文件系统被挂载，则有效位为0，未被挂载则为1</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示目前系统被格式化的设备</span></span><br><span class="line">[root@vultr ~]<span class="comment"># blkid</span></span><br><span class="line">/dev/vda1: UUID=<span class="string">"19c82273-828c-4d85-bc4e-6fc269acc524"</span> TYPE=<span class="string">"ext4"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">[root@vultr ~]<span class="comment"># dumpe2fs /dev/vda1</span></span><br><span class="line">dumpe2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">Filesystem volume name:   &lt;none&gt;</span><br><span class="line">Last mounted on:          /</span><br><span class="line">Filesystem UUID:          19c82273-828c-4d85-bc4e-6fc269acc524</span><br><span class="line">Filesystem magic number:  0xEF53</span><br><span class="line">Filesystem revision <span class="comment">#:    1 (dynamic)</span></span><br><span class="line">Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent 64bit flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize</span><br><span class="line">Filesystem flags:         signed_directory_hash </span><br><span class="line">Default mount options:    user_xattr acl</span><br><span class="line">Filesystem state:         clean                    <span class="comment">#文件系统状态，clean表示没问题</span></span><br><span class="line">Errors behavior:          Continue</span><br><span class="line">Filesystem OS <span class="built_in">type</span>:       Linux</span><br><span class="line">Inode count:              640000                   <span class="comment">#inode总数</span></span><br><span class="line">Block count:              2621179                  <span class="comment">#区块总数</span></span><br><span class="line">Reserved block count:     131057                   <span class="comment">#保留的区块总数</span></span><br><span class="line">Free blocks:              2026205                  <span class="comment">#还有多少可用区块</span></span><br><span class="line">Free inodes:              599345                   <span class="comment">#还有多少可用inode</span></span><br><span class="line">First block:              0</span><br><span class="line">Block size:               4096                     <span class="comment">#单个区块大小</span></span><br><span class="line">Fragment size:            4096</span><br><span class="line">Group descriptor size:    64</span><br><span class="line">Reserved GDT blocks:      248</span><br><span class="line">Blocks per group:         32768</span><br><span class="line">Fragments per group:      32768</span><br><span class="line">Inodes per group:         8000</span><br><span class="line">Inode blocks per group:   500</span><br><span class="line">Flex block group size:    16</span><br><span class="line">Filesystem created:       Wed Dec  5 17:22:49 2018</span><br><span class="line">Last mount time:          Wed Apr 10 10:10:48 2019</span><br><span class="line">Last write time:          Wed Apr 10 10:10:46 2019</span><br><span class="line">Mount count:              4</span><br><span class="line">Maximum mount count:      -1</span><br><span class="line">Last checked:             Sat Mar  9 02:38:28 2019</span><br><span class="line">Check interval:           0 (&lt;none&gt;)</span><br><span class="line">Lifetime writes:          3452 MB</span><br><span class="line">Reserved blocks uid:      0 (user root)</span><br><span class="line">Reserved blocks gid:      0 (group root)</span><br><span class="line">First inode:              11</span><br><span class="line">Inode size:          256                           <span class="comment">#inode表大小</span></span><br><span class="line">Required extra isize:     28</span><br><span class="line">Desired extra isize:      28</span><br><span class="line">Journal inode:            8</span><br><span class="line">Default directory <span class="built_in">hash</span>:   half_md4</span><br><span class="line">Directory Hash Seed:      6cbf0c8a-63c4-43df-aaba-cd82ae9cb153</span><br><span class="line">Journal backup:           inode blocks</span><br><span class="line">Journal features:         journal_incompat_revoke journal_64bit</span><br><span class="line">Journal size:             32M</span><br><span class="line">Journal length:           8192</span><br><span class="line">Journal sequence:         0x0004f118</span><br><span class="line">Journal start:            7195</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Group 0: (Blocks 0-32767) [ITABLE_ZEROED]                <span class="comment">#区块组0所占区块号码为0-32767</span></span><br><span class="line">  Checksum 0x6f25, unused inodes 0</span><br><span class="line">  Primary superblock at 0, Group descriptors at 1-2      <span class="comment">#文件系统描述说明在1-2号区块内</span></span><br><span class="line">  Reserved GDT blocks at 3-250</span><br><span class="line">  Block bitmap at 251 (+251), Inode bitmap at 267 (+267) </span><br><span class="line">                                                    <span class="comment">#区块对照表和inode对照表在251和267区块内</span></span><br><span class="line">  Inode table at 283-782 (+283)                     </span><br><span class="line">  <span class="comment">#一个inode表占256B，总共有782-283+1=500个区块，一个区块大小占4KB。所以inode的总数是500*4kB/256B</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">#以下几行记录，记录了可用的区块数，及可用的inode表述。可知，inode表为0了。</span></span><br><span class="line">  19990 free blocks, 0 free inodes, 1728 directories</span><br><span class="line">  Free blocks: 11866, 11890-11922, 11928-11935, 11943-11951, 12249, 12313, 12350, 12832-32767</span><br><span class="line">  Free inodes: </span><br><span class="line">……后续省略……</span><br></pre></td></tr></table></figure><h2 id="2-文件系统与目录树的关系"><a href="#2-文件系统与目录树的关系" class="headerlink" title="2.文件系统与目录树的关系"></a>2.文件系统与目录树的关系</h2><h3 id="2-1目录"><a href="#2-1目录" class="headerlink" title="2.1目录"></a>2.1目录</h3><p>在文件系统上创建一个目录时，文件系统会分配<strong>一个inode</strong>与<strong>至少一块区块</strong>（里面记录了子目录及文件的inode表位置编号）给目录</p><h3 id="2-2文件"><a href="#2-2文件" class="headerlink" title="2.2文件"></a>2.2文件</h3><p>在文件系统上创建一个文件时，文件系统会分配<strong>一个inode</strong>及所需个数的<strong>数据区块</strong>。</p><h3 id="2-3目录树的读取"><a href="#2-3目录树的读取" class="headerlink" title="2.3目录树的读取"></a>2.3目录树的读取</h3><p>文件存放在目录下，所以我们得要先知道该目录所对应的区块。区块里面记录了子目录及文件的inode表号。找到我想要的文件所对应的inode表号，再去找该文件的inode。找到之后就知道该文件放置在哪个区块了。</p><h2 id="3-挂载"><a href="#3-挂载" class="headerlink" title="3.挂载"></a>3.挂载</h2><p>文件系统和目录树结合的操作称为挂载</p><p>挂载点一定是目录，该目录为进入文件系统的入口</p><p>文件系统要挂载在目录树的某个目录后，我们才能使用该文件系统</p><h2 id="4-XFS文件系统"><a href="#4-XFS文件系统" class="headerlink" title="4.XFS文件系统"></a>4.XFS文件系统</h2><p>ext文件系统的支持度虽然广，但是格式化所需要时间长。因为是预先就规划好了inode和区块的位置，所以后续可以直接使用，也就是说并没有使用动态配置的做法</p><p>现在的磁盘越来越大，对于虚拟化磁盘那就更大了。对于巨型文件要考虑性能问题，不然虚拟磁盘的处理效率就会差。</p><p>xfs是一个日志式文件系统，用于高容量磁盘及高性能文件。同时还几乎有ext4文件系统有的功能。此外，inode与区块都是需要时才动态配置产生，不会预分配，所以格式化操作会很快。</p><h3 id="4-1数据区"><a href="#4-1数据区" class="headerlink" title="4.1数据区"></a>4.1数据区</h3><p>包含inode、数据区块、超级区块等数据，类似于之前ext里面的区块群组</p><h3 id="4-2文件系统活动登陆区"><a href="#4-2文件系统活动登陆区" class="headerlink" title="4.2文件系统活动登陆区"></a>4.2文件系统活动登陆区</h3><p>用来记录文件系统的变化，有点像日志区</p><h3 id="4-3实时运行区"><a href="#4-3实时运行区" class="headerlink" title="4.3实时运行区"></a>4.3实时运行区</h3><p>当有文件要被建立时，xfs会在这个区段里找一个到数个的扩展区块，将文件放置在这个区块内，等分配完毕再写入到数据区的inode与区块中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件系统&quot;&gt;&lt;a href=&quot;#文件系统&quot; class=&quot;headerlink&quot; title=&quot;文件系统&quot;&gt;&lt;/a&gt;文件系统&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;柱面&lt;/strong&gt;通常是&lt;strong&gt;分区&lt;/strong&gt;及&lt;strong&gt;文件系统&lt;/strong
      
    
    </summary>
    
      <category term="linux" scheme="https://dilidonglong.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>磁盘分区</title>
    <link href="https://dilidonglong.github.io/2019/04/30/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"/>
    <id>https://dilidonglong.github.io/2019/04/30/磁盘分区/</id>
    <published>2019-04-30T15:32:07.000Z</published>
    <updated>2019-04-30T15:32:35.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h1><h2 id="1-磁盘分区"><a href="#1-磁盘分区" class="headerlink" title="1.磁盘分区"></a>1.磁盘分区</h2><p><strong>磁盘</strong>包含：碟片（细分为<strong>扇区</strong>和<strong>磁道</strong>）、机械手臂、磁头、主轴马达</p><p><strong>扇区</strong>大小分为<strong>512B</strong>和<strong>4KB</strong></p><h3 id="1-1第一个扇区（MBR）"><a href="#1-1第一个扇区（MBR）" class="headerlink" title="1.1第一个扇区（MBR）"></a>1.1第一个扇区（MBR）</h3><p><strong>磁盘第一个扇区</strong>存放<strong>启动引导程序</strong>和<strong>磁盘分区表</strong>（格式分为<strong>MBR</strong>[Windows支持]和<strong>GPT</strong>）</p><table><thead><tr><th style="text-align:center">MBR（master boot record）</th><th style="text-align:center">启动引导程序</th><th style="text-align:center">磁盘分区表</th></tr></thead><tbody><tr><td style="text-align:center">主引导记录容量（512B）</td><td style="text-align:center">446B</td><td style="text-align:center">64B</td></tr></tbody></table><p>MBR分区表的限制：</p><blockquote><ol><li>分区最多到2TB</li><li>MBR仅占一个扇区，被破坏后，很难恢复甚至无法恢复</li><li>MBR内的启动引导程序只有446B，无法存储较多的程序代码</li></ol></blockquote><h4 id="1-1-1MBR磁盘分区表"><a href="#1-1-1MBR磁盘分区表" class="headerlink" title="1.1.1MBR磁盘分区表"></a>1.1.1MBR<strong>磁盘分区表</strong></h4><blockquote><ol><li>分区表占64B，给磁盘划分分区，其实就是对这个分区表做设置</li><li>分区表默认最多把一个磁盘分为4个分区</li><li>分区分为<strong>主要分区</strong>和<strong>扩展分区</strong></li><li>要写入数据到磁盘时，会参考这个分区表</li></ol></blockquote><h4 id="1-1-2MBR扩展分区"><a href="#1-1-2MBR扩展分区" class="headerlink" title="1.1.2MBR扩展分区"></a>1.1.2MBR扩展分区</h4><p>由于磁盘分区表的限制，最多给磁盘划分出4个分区。那么我们可以利用额外的扇区来记录更多的分区信息。</p><p>在<strong>扩展分区</strong>的某个地方来记录在扩展分区里面的其他<strong>逻辑分区</strong>信息</p><blockquote><ol><li>扩展分区最多一个</li><li>逻辑分区是在扩展分区里面划分出来的</li><li>能格式化的是主要分区和逻辑分区，扩展分区不能被格式化</li><li>逻辑分区能划分多少个，依据不同操作系统来定</li></ol></blockquote><hr><h3 id="1-2GPT磁盘分区表"><a href="#1-2GPT磁盘分区表" class="headerlink" title="1.2GPT磁盘分区表"></a>1.2GPT磁盘分区表</h3><p>现在的磁盘越来越大，如果使用磁盘阵列等技术，那么在Linux平台下看到的磁盘大小可能就有几十个TB。使用MBR格式，要划分分区时，就要2TB/2TB地划分下去。这就可能划分出好几十个分区，为了解决这个问题，就有了GPT这种磁盘分区的格式。</p><p>以前扇区大小为512B，现在已经有了4KB的扇区。为兼容所有磁盘，会使用到<strong>逻辑区块地址LBA</strong>（logical block address），LBA默认是512B。在GPT这种格式下，将磁盘的所有区块使用LBA来规划。<code>可以理解为，如果一个扇区的容量是512B，然后LBA默认是512B的话，那么一个扇区就是一个区块。如果一个扇区容量是4KB=8*512B，那么一个区块地址就是1/8扇区</code></p><p><strong>第一个LBA</strong>称为<strong>LBA0</strong></p><p><strong>MBR使用第一个扇区来记录，而GPT使用了前34个LBA区块来记录。</strong>由于MBR只有一个区块，破坏就难以恢复。不同于MBR，<strong>GPT中会用磁盘的最后34个LBA做备份</strong>。</p><h4 id="1-2-1LBA0（MBR兼容区块）"><a href="#1-2-1LBA0（MBR兼容区块）" class="headerlink" title="1.2.1LBA0（MBR兼容区块）"></a>1.2.1LBA0（MBR兼容区块）</h4><table><thead><tr><th style="text-align:center">LBA0</th><th style="text-align:center">引导启动程序</th><th style="text-align:center">特殊标志符</th></tr></thead><tbody><tr><td style="text-align:center">逻辑区块地址0</td><td style="text-align:center">446B</td><td style="text-align:center">64B，表示磁盘使用GPT格式</td></tr></tbody></table><h4 id="1-2-2LBA1（GPT表头记录）"><a href="#1-2-2LBA1（GPT表头记录）" class="headerlink" title="1.2.2LBA1（GPT表头记录）"></a>1.2.2LBA1（GPT表头记录）</h4><p>记录磁盘分区表本身的位置和大小，同时记录了备份的GPT分区位置。</p><h4 id="1-2-3LBA2-33（实际记录分区信息处）"><a href="#1-2-3LBA2-33（实际记录分区信息处）" class="headerlink" title="1.2.3LBA2-33（实际记录分区信息处）"></a>1.2.3LBA2-33（实际记录分区信息处）</h4><p><strong>从LBA2区块开始，每个LBA可以记录4组分区记录</strong>。所以一个磁盘在默认情况下，可以划分4*32=128个分区。</p><p>在MBR中，分区表的大小是64B，而在GPT中是512B。</p><p>一个区块记录4组分区，所以在GPT的分区表中，一组分区记录可以占512/4=128B的空间大小。</p><p>在这128B的空间中使用64bit来记录开始和结束的扇区号码</p><p>每个分区的最大容量限制就是：$2^{64}*512B=8ZB$</p><h2 id="2-启动程序"><a href="#2-启动程序" class="headerlink" title="2.启动程序"></a>2.启动程序</h2><p>CMOS是一个嵌入在主板的存储器，存储着各项硬件参数</p><p>BIOS是一个写入到主板的固件（<strong>固件是</strong>写入到硬件上的一个<strong>软件程序</strong>）</p><blockquote><ol><li>计算机系统在启动时，主动执行的第一个程序就是BIOS</li><li>BIOS执行后，会分析计算机里面的存储设备。比如发现了硬盘，BIOS就去找那个能启动的硬盘</li><li>找到该硬盘，就读取第一个扇区的MBR位置，找到那个446B的启动引导程序</li></ol><p>以上BIOS的任务完成，接下来就是启动引导程序干活了</p><ol start="4"><li>启动引导程序的目的是加载内核文件</li></ol><p>加载完后，启动引导程序的活也干完了</p><ol start="5"><li>之后就是内核文件开始工作，再之后就是把任务都交给我们熟悉的操作系统完成</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;磁盘分区&quot;&gt;&lt;a href=&quot;#磁盘分区&quot; class=&quot;headerlink&quot; title=&quot;磁盘分区&quot;&gt;&lt;/a&gt;磁盘分区&lt;/h1&gt;&lt;h2 id=&quot;1-磁盘分区&quot;&gt;&lt;a href=&quot;#1-磁盘分区&quot; class=&quot;headerlink&quot; title=&quot;1.磁盘分
      
    
    </summary>
    
      <category term="linux" scheme="https://dilidonglong.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>软考试题1</title>
    <link href="https://dilidonglong.github.io/2019/04/29/%E8%BD%AF%E8%80%83%E8%AF%95%E9%A2%981/"/>
    <id>https://dilidonglong.github.io/2019/04/29/软考试题1/</id>
    <published>2019-04-29T14:54:48.000Z</published>
    <updated>2019-04-29T15:14:49.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>若主机hostA的MAC地址为aa-aa-aa-aa-aa-aa，主机hostB的MAC地址为bb-bb-bb-bb-bb-bb。由hostA发出的查询hostB的MAC地址的帧格式如下图所示，则此帧中的目标MAC地址为（ D ），ARP报文中的目标MAC地址为（ C ）。</p><p><img src="/2019/04/29/软考试题1/1.png" alt="1"></p><p>问题1选项</p><p>A aa-aa-aa-aa-aa-aa</p><p>B bb-bb-bb-bb-bb-bb</p><p>C 00-00-00-00-00-00</p><p>D ff-ff-ff-ff-ff-ff</p><p>问题2选项</p><p>A aa-aa-aa-aa-aa-aa</p><p>B bb-bb-bb-bb-bb-bb</p><p>C 00-00-00-00-00-00</p><p>D ff-ff-ff-ff-ff-ff</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ol><li>数据包从上往下层层封装。在wireshark里面是可以看到其封装情况的。</li></ol><p><img src="/2019/04/29/软考试题1/2.png" alt="2"></p><p>上图就是一个arp的数据包。在中间的框中，可以知道arp报文被Ethernet（以太网）头部封装。第一个包指的是arp广播请求包，意思是“谁知道192.168.0.1的mac地址，请告诉192.168.0.114“</p><ol start="2"><li>wireshark数据包中以太网帧头部（Ethernet）包含了destination（目标mac地址），source（源mac地址），type（类型）</li></ol><p><img src="/2019/04/29/软考试题1/3.png" alt="2"></p><p>问题一里面的目的mac指的就是以太网头部里面的mac地址。</p><p>即下图中写的目标mac地址，你能看到正好就是对应wireshark数据包中的destination这段。<img src="/2019/04/29/软考试题1/4.png" alt="2"></p><ol start="3"><li><p>问题二里面，ARP报文中的目标MAC地址，指的就是wireshark数据包中，红框的target mac address。arp报文是被mac头部封装的。</p></li><li><p><strong>sender mac address</strong>表示发送方自己的mac地址；</p><p><strong>sender ip address</strong>表示发送方自己的ip地址；</p><p><strong>target mac address</strong>表示想要知道的对方的mac地址是多少，由于是广播请求，此时并不知道对方mac，所以暂时以全0替代；</p><p><strong>target ip address</strong>表示请求对方的ip地址。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;若主机hostA的MAC地址为aa-aa-aa-aa-aa-aa，主机hostB的MAC地址为bb-bb-bb-bb-bb-bb。由host
      
    
    </summary>
    
      <category term="软考" scheme="https://dilidonglong.github.io/categories/%E8%BD%AF%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>设置分类列表页</title>
    <link href="https://dilidonglong.github.io/2019/04/27/%E8%AE%BE%E7%BD%AE%E5%88%86%E7%B1%BB%E5%88%97%E8%A1%A8%E9%A1%B5/"/>
    <id>https://dilidonglong.github.io/2019/04/27/设置分类列表页/</id>
    <published>2019-04-27T02:46:42.000Z</published>
    <updated>2019-04-27T03:18:37.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设置分类列表页"><a href="#设置分类列表页" class="headerlink" title="设置分类列表页"></a>设置分类列表页</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近通过github+hexo(ocean主题)搭建了博客。期间遇到了各种问题，主要还是因为自己不是程序员，有些代码看不懂。</p><p>比如我想，以后如果文章多起来，只有一个归档可不行，最好要有个分类的界面。把文章都整理好，以后也方便自己查东西。</p><p>照着网上的操作：</p><blockquote><ol><li>先生成一个分类的网页，输入命令<code>hexo new page categories</code></li><li>找到对应网页的md文件，在其头部内添加上<code>type: &quot;categories&quot;</code></li><li>最后测试，新建一篇文章，在文章md文件头部上添加<code>categories: 分类的名称</code></li><li>保存</li><li>最后需要在主页上把分类页展现出来。</li><li>找到主题配置文件<code>_config.yml</code>。在<code>meun</code>中加入<code>分类: /categories</code></li><li>保存</li></ol></blockquote><p>上述操作做完之后，查看效果。发现文章里面是有分类的显示</p><p><img src="/2019/04/27/设置分类列表页/1.png" alt="分类显示"></p><p>但是，在主页里面点击分类的连接，进入分类网页，没有任何显示。如下图红框处，最开始是没有任何显示的.</p><p><img src="/2019/04/27/设置分类列表页/2.png" alt="2"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>网上查了大量文章，很多都只是说了配置问题，我是按配置正确操作的，但是就是解决不了。</p><p>后来看到一篇文章，猜测出应该是这个ocean主题缺少对应的代码。</p><p>参考链接：<a href="http://chensd.com/2016-06/hexo-theme-guide.html#分类列表页与分类文章列表页" target="_blank" rel="noopener">hexo主题开发指南-分类列表页与分类文章列表页</a></p><blockquote><p>分类列表页显示博客里的所有分类，分类文章列表页显示某个分类中的文章列表。</p><p>Hexo 并没有专门分类列表页的模板，那该如何处理呢？一般是写在页面模板中，即 <code>layout/page.swig</code> 里，然后判断页面类型变量 <code>page.type</code>，如果是 <code>categories</code>，则显示分类列表页。再在博客里创建一个页面，指定其 <code>type</code> 为 <code>categories</code> </p></blockquote><p>ocean主题是用ejs写出来的。而这个链接里面给的是swig的代码。所以估计不能直接用</p><p>定位了问题，接下来就好处理了。由于我暂时还不会写代码，所以只好找答案复制粘贴。</p><p>参考链接：<a href="http://orzcss.com/posts/5a207d64/" target="_blank" rel="noopener">Hexo-创建分类（categories）和标签（tags）首页</a>，给出如下代码</p><blockquote><p>找到 <code>layout/_partial/article.ejs</code> </p><p>然后找到 <code>&lt;div class=&quot;article-entry&quot; itemprop=&quot;articleBody&quot;&gt;</code> 这一行</p><p>这个 div 里面的内容全部替换为：(注：再此处，我没有全部替换，而是补充接在原始文档内容后了)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt;% if (page.type === "tags") &#123; %&gt;</span><br><span class="line">&gt; &lt;div class="tag-cloud"&gt;</span><br><span class="line">&gt; &lt;div class="tag-cloud-title"&gt;</span><br><span class="line">&gt; &lt;%- _p('counter.tag_cloud', site.tags.length) %&gt;</span><br><span class="line">&gt; &lt;/div&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &lt;div class="tag-cloud-tags"&gt;</span><br><span class="line">&gt; &lt;%- tagcloud(&#123;</span><br><span class="line">&gt; min_font: 12,</span><br><span class="line">&gt; max_font: 30,</span><br><span class="line">&gt; amount: 200,</span><br><span class="line">&gt; color: true,</span><br><span class="line">&gt; start_color: '#ccc',</span><br><span class="line">&gt; end_color: '#111'</span><br><span class="line">&gt; &#125;) %&gt;</span><br><span class="line">&gt; &lt;/div&gt;</span><br><span class="line">&gt; &lt;/div&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &lt;% &#125; else if (page.type === 'categories') &#123; %&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &lt;div class="category-all-page"&gt;</span><br><span class="line">&gt; &lt;div class="category-all-title"&gt;</span><br><span class="line">&gt; &lt;%- _p('counter.categories', site.categories.length) %&gt;</span><br><span class="line">&gt; &lt;/div&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &lt;div class="category-all"&gt;</span><br><span class="line">&gt; &lt;%- list_categories() %&gt;</span><br><span class="line">&gt; &lt;/div&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &lt;/div&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &lt;% &#125; else &#123; %&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &lt;% if (post.excerpt &amp;&amp; index)&#123; %&gt;&lt;%- post.excerpt %&gt;</span><br><span class="line">&gt; &lt;% &#125; else &#123; %&gt;</span><br><span class="line">&gt; &lt;%- post.content %&gt;</span><br><span class="line">&gt; &lt;% &#125; %&gt;</span><br><span class="line">&gt; &lt;% &#125; %&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>修改样式，如果觉得不好看，自己改喜欢的样式</p><p>找到 <code>yilia/source/css/_partial/article.styl</code> 在最后面添加下面的 css 代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/*tag-cloud*/</span></span><br><span class="line">&gt; <span class="selector-class">.tag-cloud</span> &#123;</span><br><span class="line">&gt;   text-align: center;</span><br><span class="line">&gt;   <span class="selector-tag">margin-top</span>: 50<span class="selector-tag">px</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="selector-class">.tag-cloud</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">&gt;   display: inline-block;</span><br><span class="line">&gt;   <span class="selector-tag">margin</span>: 10<span class="selector-tag">px</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="selector-class">.tag-cloud-title</span> &#123;</span><br><span class="line">&gt;   font-weight: 700;</span><br><span class="line">&gt;   <span class="selector-tag">font-size</span>: 24<span class="selector-tag">px</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="selector-class">.tag-cloud-tags</span> &#123;</span><br><span class="line">&gt;   margin-top: 15px;</span><br><span class="line">&gt;   <span class="selector-tag">a</span> &#123;</span><br><span class="line">&gt;     display: inline-block;</span><br><span class="line">&gt;     <span class="selector-tag">text-decoration</span>: <span class="selector-tag">none</span>;</span><br><span class="line">&gt;     <span class="selector-tag">font-weight</span>: <span class="selector-tag">normal</span>;</span><br><span class="line">&gt;     <span class="selector-tag">font-size</span>: 10<span class="selector-tag">px</span>;</span><br><span class="line">&gt;     <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span><br><span class="line">&gt;     <span class="selector-tag">line-height</span>: <span class="selector-tag">normal</span>;</span><br><span class="line">&gt;     <span class="selector-tag">padding</span>: 5<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> 10<span class="selector-tag">px</span>;</span><br><span class="line">&gt;     <span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;</span><br><span class="line">&gt;     <span class="selector-tag">border-radius</span>: 0 5<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> 0;</span><br><span class="line">&gt;     <span class="selector-tag">font-family</span>: <span class="selector-tag">Menlo</span>, <span class="selector-tag">Monaco</span>, "<span class="selector-tag">Andale</span> <span class="selector-tag">Mono</span>", "<span class="selector-tag">lucida</span> <span class="selector-tag">console</span>", "<span class="selector-tag">Courier</span> <span class="selector-tag">New</span>", <span class="selector-tag">monospace</span>;</span><br><span class="line">&gt;     &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">&gt;       opacity: 0.8;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     &amp;<span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">&gt;       content: " ";</span><br><span class="line">&gt;       <span class="selector-tag">width</span>: 0;</span><br><span class="line">&gt;       <span class="selector-tag">height</span>: 0;</span><br><span class="line">&gt;       <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">&gt;       <span class="selector-tag">top</span>: 0;</span><br><span class="line">&gt;       <span class="selector-tag">left</span>: <span class="selector-tag">-18px</span>;</span><br><span class="line">&gt;       <span class="selector-tag">border</span>: 9<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">transparent</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     &amp;<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">&gt;       content: " ";</span><br><span class="line">&gt;       <span class="selector-tag">width</span>: 4<span class="selector-tag">px</span>;</span><br><span class="line">&gt;       <span class="selector-tag">height</span>: 4<span class="selector-tag">px</span>;</span><br><span class="line">&gt;       <span class="selector-tag">background-color</span>: <span class="selector-id">#fff</span>;</span><br><span class="line">&gt;       <span class="selector-tag">border-radius</span>: 4<span class="selector-tag">px</span>;</span><br><span class="line">&gt;       <span class="selector-tag">box-shadow</span>: 0 0 0 1<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0, 0, 0, <span class="selector-class">.3</span>);</span><br><span class="line">&gt;       <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">&gt;       <span class="selector-tag">top</span>: 7<span class="selector-tag">px</span>;</span><br><span class="line">&gt;       <span class="selector-tag">left</span>: 2<span class="selector-tag">px</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   <span class="selector-tag">a</span><span class="selector-class">.color1</span> &#123;</span><br><span class="line">&gt;     background: #FF945C;</span><br><span class="line">&gt;     &amp;<span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">&gt;       border-right-color: #FF945C;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   <span class="selector-tag">a</span><span class="selector-class">.color2</span> &#123;</span><br><span class="line">&gt;     background: #F5C7B7;</span><br><span class="line">&gt;     &amp;<span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">&gt;       border-right-color: #F5C7B7;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   <span class="selector-tag">a</span><span class="selector-class">.color3</span> &#123;</span><br><span class="line">&gt;     background: #BA8F6C;</span><br><span class="line">&gt;     &amp;<span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">&gt;       border-right-color: #BA8F6C;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   <span class="selector-tag">a</span><span class="selector-class">.color4</span> &#123;</span><br><span class="line">&gt;     background: #CFB7C4;</span><br><span class="line">&gt;     &amp;<span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">&gt;       border-right-color: #CFB7C4;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   <span class="selector-tag">a</span><span class="selector-class">.color5</span> &#123;</span><br><span class="line">&gt;     background: #7B5D5F;</span><br><span class="line">&gt;     &amp;<span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">&gt;       border-right-color: #7B5D5F;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/*category-all-page*/</span></span><br><span class="line">&gt; <span class="selector-class">.category-all-page</span> &#123;</span><br><span class="line">&gt;   margin-top: 50px;</span><br><span class="line">&gt;   <span class="selector-class">.category-all-title</span> &#123;</span><br><span class="line">&gt;     font-weight: 700;</span><br><span class="line">&gt;     <span class="selector-tag">font-size</span>: 24<span class="selector-tag">px</span>;</span><br><span class="line">&gt;     <span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   <span class="selector-class">.category-list-item</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">&gt;     content: '';</span><br><span class="line">&gt;     <span class="selector-tag">clear</span>: <span class="selector-tag">both</span>;</span><br><span class="line">&gt;     <span class="selector-tag">display</span>: <span class="selector-tag">table</span>;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   <span class="selector-class">.category-list-count</span> &#123;</span><br><span class="line">&gt;     float: right;</span><br><span class="line">&gt;     <span class="selector-tag">margin-left</span>: 5<span class="selector-tag">px</span>;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   <span class="selector-class">.category-list-count</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">&gt;     content: '一共 ';</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   <span class="selector-class">.category-list-count</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">&gt;     content: ' 篇文章';</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>通过上述操作，问题解决。不过显示出来的样式不是自己喜欢的那种。等以后自己学会编程，再回头过来修改吧～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设置分类列表页&quot;&gt;&lt;a href=&quot;#设置分类列表页&quot; class=&quot;headerlink&quot; title=&quot;设置分类列表页&quot;&gt;&lt;/a&gt;设置分类列表页&lt;/h1&gt;&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问
      
    
    </summary>
    
      <category term="小技巧" scheme="https://dilidonglong.github.io/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>tshark使用方法</title>
    <link href="https://dilidonglong.github.io/2019/04/26/tshark%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://dilidonglong.github.io/2019/04/26/tshark使用方法/</id>
    <published>2019-04-25T16:10:34.000Z</published>
    <updated>2019-04-25T16:32:27.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tshark使用方法"><a href="#tshark使用方法" class="headerlink" title="tshark使用方法"></a>tshark使用方法</h1><p><a href="https://www.wireshark.org/docs/man-pages/tshark.html" target="_blank" rel="noopener">tshark官方文档</a></p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p><strong>TShark</strong> is a network protocol analyzer. It lets you capture packet data from a live network, or read packets from a previously saved capture file, either printing a decoded form of those packets to the standard output or writing the packets to a file. <strong>TShark</strong>‘s native capture file format is <strong>pcapng</strong> format, which is also the format used by <strong>wireshark</strong> and various other tools.</p><p><strong>TShark</strong>是一个网络分析工具。它能帮你在实时网络中捕获数据包，或是从预先保存好的捕获文件中读取数据包，或是打印出这些数据包的解码形式到标准输出，再或是把数据包写入到一个文件中。<strong>TShark</strong>的本地捕获文件格式是pcapng格式，这种pcapng格式也被<strong>wireshark</strong>和多种其他工具使用。</p><p>Without any options set, <strong>TShark</strong> will work much like <strong>tcpdump</strong>. It will use the pcap library to capture traffic from the first available network interface and displays a summary line on the standard output for each received packet.</p><p>如果没有设置任何选项，<strong>TShark</strong>将像<strong>tcpdump</strong>一样工作。它使用pcap库，从第一个可使用的网络接口捕获流量。并且为每个接收到的包展示其摘要行到标准输出上。</p><p>When run with the <strong>-r</strong> option, specifying a capture file from which to read, <strong>TShark</strong> will again work much like <strong>tcpdump</strong>, reading packets from the file and displaying a summary line on the standard output for each packet read. <strong>TShark</strong> is able to detect, read and write the same capture files that are supported by <strong>Wireshark</strong>. The input file doesn’t need a specific filename extension; the file format and an optional gzip compression will be automatically detected. Near the beginning of the DESCRIPTION section of wireshark(1) or <a href="https://www.wireshark.org/docs/man-pages/wireshark.html" target="_blank" rel="noopener">https://www.wireshark.org/docs/man-pages/wireshark.html</a> is a detailed description of the way <strong>Wireshark</strong> handles this, which is the same way <strong>Tshark</strong> handles this.</p><p>当使用-r选项，会从我们指定的文件中读取数据包信息。<strong>TShark</strong>将再次像<strong>tcpdump</strong>一样工作，从文件中读取数据包并且把读取的数据包在标准输出上展示其摘要行。<strong>TShark</strong>可以检测，读取和写入同一份捕获文件，这些操作在<strong>Wireshark</strong>中也是支持的。输出文件不需要一个指定的文件扩展名；它将动态检测文件格式和可选的gzip压缩。在<strong>Wireshark</strong>的开始描述部分附近或是在链接<a href="https://www.wireshark.org/docs/man-pages/wireshark.html" target="_blank" rel="noopener">https://www.wireshark.org/docs/man-pages/wireshark.html</a> 中，介绍了关于<strong>Wireshark</strong>处理这些问题的方法细节描述，这些方法同样适用于<strong>TShark</strong>。</p><p>Compressed file support uses (and therefore requires) the zlib library. If the zlib library is not present when compiling <strong>TShark</strong>, it will be possible to compile it, but the resulting program will be unable to read compressed files.</p><p>支持压缩文件要使用（因此需要）zlib库。如果编译<strong>TShark</strong>时zlib库不存在，也可以编译它，但是最终程序将不可读取压缩文件。</p><p>When displaying packets on the standard output, <strong>TShark</strong> writes, by default, a summary line containing the fields specified by the preferences file (which are also the fields displayed in the packet list pane in <strong>Wireshark</strong>), although if it’s writing packets as it captures them, rather than writing packets from a saved capture file, it won’t show the “frame number” field. If the <strong>-V</strong> option is specified, it instead writes a view of the details of the packet, showing all the fields of all protocols in the packet. If the <strong>-O</strong> option is specified, it will only show the full details for the protocols specified, and show only the top-level detail line for all other protocols. Use the output of “<strong>tshark -G protocols</strong>“ to find the abbreviations of the protocols you can specify. If the <strong>-P</strong> option is specified with either the <strong>-V</strong> or <strong>-O</strong> options, both the summary line for the entire packet and the details will be displayed.</p><p>当在标准输出显示数据包时，默认情况下<strong>TShark</strong>输出摘要行信息，摘要行里包含首选项文件指定的字段（这些字段也展示在wireshark中的包列表窗），但是如果在捕获流量时输出数据包而不是在保存的文件中输出数据包的话，将不会显示“帧编号”字段。如果指定了<strong>-V</strong>选项，这将输出数据包的细节信息视图，展示了数据包中所有协议的所有字段信息。如果指定了<strong>-O</strong>选项，它将仅显示指定协议的完整详细信息，并仅显示所有其他协议的顶级详细信息行。在命令行中输入“<strong>tshark -G protocols</strong>”可以查找指定的协议缩写。如果<strong>-P</strong>选项和<strong>-V</strong>或<strong>-O</strong>一起使用，将会展示整个包的摘要行和细节信息。</p><p>Packet capturing is performed with the pcap library. That library supports specifying a filter expression; packets that don’t match that filter are discarded. The <strong>-f</strong> option is used to specify a capture filter. The syntax of a capture filter is defined by the pcap library; this syntax is different from the read filter syntax described below, and the filtering mechanism is limited in its abilities.</p><p>数据包捕获时使用pcap库。pcap库支持指定的过滤表达式；数据包没有匹配上过滤表达式则会被丢弃。<strong>-f</strong>选项被用来指定捕获过滤表达式。捕获过滤的语法在pcap库中定义；这些捕获过滤的语法不同于以下所描述的显示过滤器语法，并且其过滤机制的能力有限。</p><p>Read filters in <strong>TShark</strong>, which allow you to select which packets are to be decoded or written to a file, are very powerful; more fields are filterable in <strong>TShark</strong> than in other protocol analyzers, and the syntax you can use to create your filters is richer. As <strong>TShark</strong> progresses, expect more and more protocol fields to be allowed in read filters. Read filters use the same syntax as display and color filters in <strong>Wireshark</strong>; a read filter is specified with the <strong>-R</strong> option.</p><p>在<strong>TShark</strong>中的显示过滤器允许你选择哪一个包被解码或是把该数据包写入到一个文件，这是很强大的功能；<strong>TShark</strong>相比于其他协议分析器可以过滤出更多的字段，并且你能使用并创建的过滤器语法更为丰富。随着<strong>TShark</strong>的发展，期待更多协议字段被允许出现在显示过滤器中。显示过滤器使用与<strong>wireshark</strong>中的展示和色彩过滤器一样的语法；使用<strong>-R</strong>选项来指定显示过滤器。</p><p>Read filters can be specified when capturing or when reading from a capture file. Note that that capture filters are much more efficient than read filters, and it may be more difficult for <strong>TShark</strong> to keep up with a busy network if a read filter is specified for a live capture, so you might be more likely to lose packets if you’re using a read filter.</p><p>当正在捕获或是从一个捕获文件中读取时是可以指定显示过滤器的。需要注意的是捕获过滤器比显示过滤器会更有效率；并且在一个繁忙的网络中如果进行实时捕获时使用了显示过滤器，那么<strong>TShark</strong>可能更难跟上这个繁忙网络，同时你要是使用了显示过滤器还可能会丢失数据包。</p><p>A capture or read filter can either be specified with the <strong>-f</strong> or <strong>-R</strong> option, respectively, in which case the entire filter expression must be specified as a single argument (which means that if it contains spaces, it must be quoted), or can be specified with command-line arguments after the option arguments, in which case all the arguments after the filter arguments are treated as a filter expression. If the filter is specified with command-line arguments after the option arguments, it’s a capture filter if a capture is being done (i.e., if no <strong>-r</strong> option was specified) and a read filter if a capture file is being read (i.e., if a <strong>-r</strong> option was specified).</p><p>捕获或是显示过滤器能分别使用<strong>-f</strong>或是<strong>-R</strong>选项来指定。在这种情况下，整个过滤表达式必须作为一个参数被指定（这意味着如果含有空格，就需要使用“ ”被引用）；或者是在选项参数之后使用命令行参数被指定，在这种情况下，所有在过滤器参数之后的参数会被视为过滤表达式。如果在选项参数后，使用命令行参数来指定过滤器，那么捕获正在进行时它就是捕获过滤器（即，没有-r选项）；如果捕获文件正在被读取，那么它就是显示过滤器（即，<strong>-r</strong>选项是被指定的）。</p><p>If the <strong>-w</strong> option is specified when capturing packets or reading from a capture file, <strong>TShark</strong> does not display packets on the standard output. Instead, it writes the packets to a capture file with the name specified by the <strong>-w</strong> option.</p><p>当正在捕获数据包，或是从一个捕获文件中读取时，如果使用了-w选项，那么<strong>TShark</strong>不会在标准输出上显示数据包。相反，它将把数据包写入捕获文件，其名称由<strong>-w</strong>选项指定。</p><p>If you want to write the decoded form of packets to a file, run <strong>TShark</strong> without the <strong>-w</strong> option, and redirect its standard output to the file (do <em>not</em> use the <strong>-w</strong> option).</p><p>如果要将解码后的数据包形式写入文件，那么使用<strong>TShark</strong>时不要带上-w选项，同时会将其标准输出重定向到文件。（不要使用<strong>-w</strong>选项）</p><p>If you want the packets to be displayed to the standard output and also saved to a file, specify the <strong>-P</strong> option in addition to the <strong>-w</strong> option to have the summary line displayed, specify the <strong>-V</strong> option in addition to the <strong>-w</strong> option to have the details of the packet displayed, and specify the <strong>-O</strong> option, with a list of protocols, to have the full details of the specified protocols and the top-level detail line for all other protocols to be displayed. If the <strong>-P</strong> option is used together with the <strong>-V</strong> or <strong>-O</strong> option, the summary line will be displayed along with the detail lines.</p><p>如果你想数据包在标准输出上显示并且还能保存到一个文件中，那么除了-w选项还需要指定-P选项来显示摘要行。使用<strong>-w</strong>选项及<strong>-V</strong>选项将展示数据包的细节。如果再加上<strong>-O</strong>选项，带上了列出的协议，将显示指定协议的所有细节以及所有其他协议的顶层细节行。如果<strong>-P</strong>选项和<strong>-V</strong>或是<strong>-O</strong>选项一起使用，那么摘要行将会和细节信息一起展示。</p><p>When writing packets to a file, <strong>TShark</strong>, by default, writes the file in <strong>pcapng</strong> format, and writes all of the packets it sees to the output file. The <strong>-F</strong> option can be used to specify the format in which to write the file. This list of available file formats is displayed by the <strong>-F</strong> option without a value. However, you can’t specify a file format for a live capture.</p><p>当把数据包写入一个文件，<strong>TShark</strong>默认情况下会使用<strong>pcapng</strong>格式，并将其所有看到的包写入到输出文件。使用<strong>-F</strong>选项可以指定输出文件的格式。使用<strong>-F</strong>选项不带任何参数值，将显示可以得到的文件格式列表。但是对于实时捕获，你不能指定其文件格式。</p><p>When capturing packets, <strong>TShark</strong> writes to the standard error an initial line listing the interfaces from which packets are being captured and, if packet information isn’t being displayed to the terminal, writes a continuous count of packets captured to the standard output. If the <strong>-q</strong> option is specified, neither the continuous count nor the packet information will be displayed; instead, at the end of the capture, a count of packets captured will be displayed. If the <strong>-Q</strong> option is specified, neither the initial line, nor the packet information, nor any packet counts will be displayed. If the <strong>-q</strong> or <strong>-Q</strong> option is used, the <strong>-P</strong>, <strong>-V</strong>, or <strong>-O</strong> option can be used to cause the corresponding output to be displayed even though other output is suppressed.</p><p>当正在捕获数据包时，<strong>TShark</strong>把捕获到数据包接口的初始化行写入到标准错误中。如果数据包信息没有被展示在终端，则将写入连续的捕获数据包统计到标准输出。如果<strong>-q</strong>选项被指定，则不管是连续统计还是数据包信息都不会被展示出来；相反，在捕获结束后，被捕获的数据包统计将会显示出来。如果<strong>-Q</strong>选项被指定，初始化行、数据包信息或是任何一个数据包统计都不会被展示。如果使用<strong>-q</strong>或<strong>-Q</strong>选项，则可以使用<strong>-P</strong>，<strong>-V</strong>或<strong>-O</strong>选项来显示相应的输出，即使其他输出被抑制也是如此。</p><p>When reading packets, the <strong>-q</strong> and <strong>-Q</strong> option will suppress the display of the packet summary or details; this would be used if <strong>-z</strong> options are specified in order to display statistics, so that only the statistics, not the packet information, is displayed.</p><p>读取数据包时，<strong>-q</strong>和<strong>-Q</strong>选项将禁止显示数据包摘要或详细信息;如果指定<strong>-z</strong>选项以显示统计信息，那么只有统计信息会被展示，而不会展示数据包信息。</p><p>The <strong>-G</strong> option is a special mode that simply causes <strong>Tshark</strong> to dump one of several types of internal glossaries and then exit.</p><p><strong>-G</strong>选项是一种特殊模式，它只会导致<strong>TShark</strong>转储几种类型的内部词汇表中的一种，然后退出。</p><hr><h2 id="2-选项概要"><a href="#2-选项概要" class="headerlink" title="2.选项概要"></a>2.选项概要</h2><p><strong>Capture interface:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-i &lt;interface&gt;               <span class="comment"># name or idx of interface (def: first non-loopback)</span></span><br><span class="line">-f &lt;capture filter&gt;          <span class="comment"># packet filter in libpcap filter syntax</span></span><br><span class="line">-s &lt;snaplen&gt;                 <span class="comment"># packet snapshot length (def: 262144)</span></span><br><span class="line">-p                           <span class="comment"># don't capture in promiscuous mode</span></span><br><span class="line">-I                           <span class="comment"># capture in monitor mode, if available</span></span><br><span class="line">-B &lt;buffer size&gt;             <span class="comment"># size of kernel buffer (def: 4MB)</span></span><br><span class="line">-y &lt;link <span class="built_in">type</span>&gt;               <span class="comment"># link layer type (def: first appropriate)</span></span><br><span class="line">-D                           <span class="comment"># print list of interfaces and exit</span></span><br><span class="line">-L                           <span class="comment"># print list of link-layer types of iface and exit</span></span><br></pre></td></tr></table></figure><p><strong>Capture stop conditions:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-c &lt;packet count&gt;             <span class="comment"># stop after n packets (def: infinite)</span></span><br><span class="line">-a &lt;autostop cond.&gt; ...  </span><br><span class="line">​                             duration:NUM - stop after NUM seconds</span><br><span class="line">​                             filesize:NUM - stop this file after NUM KB</span><br><span class="line">​                             files:NUM - stop after NUM files</span><br></pre></td></tr></table></figure><p><strong>Capture output:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-b &lt;ringbuffer opt.&gt; ... </span><br><span class="line"></span><br><span class="line">​                            duration:NUM - switch to next file after NUM secs</span><br><span class="line">​                            filesize:NUM - switch to next file after NUM KB</span><br><span class="line">​                            files:NUM - ringbuffer: replace after NUM files</span><br></pre></td></tr></table></figure><p><strong>Input file:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-r &lt;infile&gt;                  <span class="comment"># set the filename to read from (no stdin!)</span></span><br></pre></td></tr></table></figure><p><strong>Processing:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-2                           <span class="comment"># perform a two-pass analysis</span></span><br><span class="line">-R &lt;<span class="built_in">read</span> filter&gt;             <span class="comment"># packet Read filter in Wireshark display filter syntax</span></span><br><span class="line">-Y &lt;display filter&gt;          <span class="comment"># packet displaY filter in Wireshark display filter syntax</span></span><br><span class="line">-n                           <span class="comment"># disable all name resolutions (def: all enabled)</span></span><br><span class="line">-N &lt;name resolve flags&gt;      <span class="comment"># enable specific name resolution(s): "mnNtC"</span></span><br><span class="line">-d &lt;layer_type&gt;== &lt;selector&gt;,&lt;decode_as_protocol&gt; ...</span><br><span class="line">                             <span class="comment"># "Decode As", see the man page for details</span></span><br><span class="line">                             <span class="comment"># Example: tcp.port==8888,http</span></span><br><span class="line">-H &lt;hosts file&gt;         </span><br><span class="line">​            <span class="built_in">read</span> a list of entries from a hosts file, <span class="built_in">which</span> will  <span class="keyword">then</span> be written to a capture file. (Implies -W n)</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">-w &lt;outfile|-&gt;               <span class="comment"># write packets to a pcap-format file named "outfile"</span></span><br><span class="line">                             <span class="comment"># (or to the standard output for "-")</span></span><br><span class="line">                             </span><br><span class="line">-C &lt;config profile&gt;          <span class="comment"># start with specified configuration profile</span></span><br><span class="line">-F &lt;output file <span class="built_in">type</span>&gt;        <span class="comment"># set the output file type, default is pcapng</span></span><br><span class="line">                             <span class="comment"># an empty "-F" option will list the file types</span></span><br><span class="line">                             </span><br><span class="line">-V                           <span class="comment"># add output of packet tree (Packet Details)</span></span><br><span class="line">-O &lt;protocols&gt;               <span class="comment"># Only show packet details of these protocols, comma                                        separated</span></span><br><span class="line"></span><br><span class="line">-P                           <span class="comment"># print packet summary even when writing to a file</span></span><br><span class="line">-S &lt;separator&gt;               <span class="comment"># the line separator to print between packets</span></span><br><span class="line">-x                           <span class="comment"># add output of hex and ASCII dump (Packet Bytes)</span></span><br><span class="line">-T pdml|ps|psml|text|fields  <span class="comment"># format of text output (def: text)</span></span><br><span class="line"></span><br><span class="line">-e &lt;field&gt;                   <span class="comment"># field to print if -Tfields selected (e.g. tcp.port,                                      col.Info);this option can be repeated to print multiple                                  fields</span></span><br><span class="line"></span><br><span class="line">-E&lt;fieldsoption&gt;=&lt;value&gt;     <span class="comment"># set options for output when -Tfields selected:</span></span><br><span class="line">     header=y|n                 switch headers on and off</span><br><span class="line">     separator=/t|/s|&lt;char&gt;     select tab, space, printable character as separator</span><br><span class="line">     occurrence=f|l|a           <span class="built_in">print</span> first, last or all occurrences of each field</span><br><span class="line">     aggregator=,|/s|&lt;char&gt;     select comma, space, printable character as  aggregator</span><br><span class="line">     quote=d|s|n                select double, single, no quotes <span class="keyword">for</span> values</span><br><span class="line">     </span><br><span class="line">-t a|ad|d|dd|e|r|u|ud        <span class="comment"># output format of time stamps (def: r: rel. to first)</span></span><br><span class="line">-u s|hms                     <span class="comment"># output format of seconds (def: s: seconds)</span></span><br><span class="line">-l                           <span class="comment"># flush standard output after each packet</span></span><br><span class="line">-q                           <span class="comment"># be more quiet on stdout (e.g. when using statistics)</span></span><br><span class="line">-Q                           <span class="comment"># only log true errors to stderr (quieter than -q)</span></span><br><span class="line">-g                           <span class="comment"># enable group read access on the output file(s)</span></span><br><span class="line">-W n                         <span class="comment"># Save extra information in the file, if supported.</span></span><br><span class="line">                             <span class="comment"># n = write network address resolution information</span></span><br><span class="line">  </span><br><span class="line">-X &lt;key&gt;:&lt;value&gt;             <span class="comment"># eXtension options, see the man page for details</span></span><br><span class="line">-z &lt;statistics&gt;              <span class="comment"># various statistics, see the man page for details</span></span><br></pre></td></tr></table></figure><p><strong>Miscellaneous:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-h                           <span class="comment"># display this help and exit</span></span><br><span class="line">-v                           <span class="comment"># display version info and exit</span></span><br><span class="line">-o &lt;name&gt;:&lt;value&gt; ...        <span class="comment"># override preference setting</span></span><br><span class="line">-K &lt;keytab&gt;                  <span class="comment"># keytab file to use for kerberos decryption</span></span><br><span class="line">-G [report]                  <span class="comment"># dump one of several available reports and exit</span></span><br><span class="line">                             <span class="comment"># default report="fields"  </span></span><br><span class="line">                             <span class="comment"># use "-G ?" for more help</span></span><br></pre></td></tr></table></figure><hr><h2 id="3-选项细节"><a href="#3-选项细节" class="headerlink" title="3.选项细节"></a>3.选项细节</h2><h3 id="3-1-Capture-interface-捕获接口"><a href="#3-1-Capture-interface-捕获接口" class="headerlink" title="3.1 Capture interface:捕获接口"></a>3.1 Capture interface:捕获接口</h3><h4 id="i-指定接口"><a href="#i-指定接口" class="headerlink" title="-i        指定接口"></a>-i        指定接口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-i &lt;interface&gt;               <span class="comment"># name or idx of interface (def: first non-loopback)</span></span><br></pre></td></tr></table></figure><p>Set the name of the network interface or pipe to use for live packet capture.</p><p>为实时数据包捕获设置网络接口或管道的名称。</p><p>Network interface names should match one of the names listed in “<strong>tshark -D</strong>“ (described above); a number, as reported by “<strong>tshark -D</strong>“, can also be used. If you’re using UNIX, “<strong>netstat -i</strong>“, “<strong>ifconfig -a</strong>“ or “<strong>ip link</strong>“ might also work to list interface names, although not all versions of UNIX support the <strong>-a</strong> option to <strong>ifconfig</strong>.</p><p>网络接口名称应该是使用“<strong>tshark -D</strong>”命令后显示的接口名称列表中的一个。当然也可以使用“<strong>tshark -D</strong>”展示的列表中的数字。如果你使用UNIX系统，“<strong>netstat -i</strong>”，“<strong>ifconfig -a</strong>”或是“<strong>iplink</strong>”也可以显示出接口名称，尽管不是所有的NUIX版本都支持在<strong>ifconfig</strong>中使用<strong>-a</strong>参数。</p><p><img src="/2019/04/26/tshark使用方法/1553424287090.png" alt="1553424287090"></p><p>If no interface is specified, <strong>TShark</strong> searches the list of interfaces, choosing the first non-loopback interface if there are any non-loopback interfaces, and choosing the first loopback interface if there are no non-loopback interfaces. If there are no interfaces at all, <strong>TShark</strong> reports an error and doesn’t start the capture.</p><p>如果没有接口被指定，<strong>TShark</strong>寻找接口列表，若在列表中存在多个非回环接口，将选择第一个非回环接口。若在列表中没有非回环接口，则选择第一个回环接口。如果设备没有一个接口，那<strong>TShark</strong>会报告一个错误，并且不会开始捕获数据。</p><p>Pipe names should be either the name of a FIFO (named pipe) or “-“ to read data from the standard input. On Windows systems, pipe names must be of the form “\\pipe\.\pipename”. Data read from pipes must be in standard pcapng or pcap format. Pcapng data must have the same endianness as the capturing host.</p><p>管道名称（此处略）</p><p>This option can occur multiple times. When capturing from multiple interfaces, the capture file will be saved in pcapng format.</p><p>这个选项可以出现多次。当从多个接口进行数据捕获，捕获文件将被保存为pcapng格式。</p><p><img src="/2019/04/26/tshark使用方法/1553424388817.png" alt="1553424388817"></p><h4 id="f-设置捕获时的过滤条件"><a href="#f-设置捕获时的过滤条件" class="headerlink" title="-f        设置捕获时的过滤条件"></a>-f        设置捕获时的过滤条件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-f &lt;capture filter&gt;            <span class="comment"># packet filter in libpcap filter syntax</span></span><br></pre></td></tr></table></figure><p>Set the capture filter expression.设置捕获过滤器表达式</p><p>This option can occur multiple times. If used before the first occurrence of the <strong>-i</strong> option, it sets the default capture filter expression. If used after an <strong>-i</strong> option, it sets the capture filter expression for the interface specified by the last <strong>-i</strong> option occurring before this option. If the capture filter expression is not set specifically, the default capture filter expression is used if provided.</p><p>这个选项可以多次出现。如果在第一次出现<strong>-i</strong>选项之前使用，则会设置默认的捕获过滤器表达式。如果在<strong>-i</strong>选项之后使用，则会为最后一个<strong>-i</strong>选项指定的接口设置捕获过滤器表达式。如果捕获过滤器表达式没有设置指定，则使用默认的捕获过滤表达式（如果提供的话）</p><p>Pre-defined capture filter names, as shown in the GUI menu item Capture-&gt;Capture Filters, can be used by prefixing the argument with “predef:”. Example: <strong>tshark -f “predef:MyPredefinedHostOnlyFilter”</strong></p><p>通过在参数前面添加前缀”predef:”可以使用预定义捕获过滤器名称，就像在GUI菜单选项 Capture-&gt;Capture Filters中一样。举个例子：<strong>tshark -f “predef:MyPredefinedHostOnlyFilter”</strong></p><p><img src="/2019/04/26/tshark使用方法/1553424447858.png" alt="1553424447858"></p><p>ps：捕获过滤器条件写法参考自己之前做的总结文档</p><h4 id="s-设置捕获的数据包长度"><a href="#s-设置捕获的数据包长度" class="headerlink" title="-s        设置捕获的数据包长度"></a>-s        设置捕获的数据包长度</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-s &lt;snaplen&gt;                <span class="comment"># packet snapshot length (def: 262144)</span></span><br></pre></td></tr></table></figure><p>Set the default snapshot length to use when capturing live data. No more than <em>snaplen</em> bytes of each network packet will be read into memory, or saved to disk. A value of 0 specifies a snapshot length of 262144, so that the full packet is captured; this is the default.</p><p>当在捕获实时数据时，设置一个默认的快照长度。每个网络数据包的快照字节将会读入到内存或是保存在硬盘中。</p><p>数值0指定了快照长度是262144字节，以便捕获完整数据包；这个也是默认的。</p><p>This option can occur multiple times. If used before the first occurrence of the <strong>-i</strong> option, it sets the default snapshot length. If used after an <strong>-i</strong> option, it sets the snapshot length for the interface specified by the last <strong>-i</strong> option occurring before this option. If the snapshot length is not set specifically, the default snapshot length is used if provided.</p><p>这个选项能出现多次。如果在第一次出现<strong>-i</strong>选项前使用，则将设置默认的快照长度。如果在<strong>-i</strong>选项后使用，则将为最后一个出现的<strong>-i</strong>选项所指定的接口设置快照长度。如果快照长度没有被指定，则使用默认的快照长度（如果被提供的话）</p><p><img src="/2019/04/26/tshark使用方法/1553424534932.png" alt="1553424534932"></p><h4 id="p-设置接口为非混杂模式"><a href="#p-设置接口为非混杂模式" class="headerlink" title="-p        设置接口为非混杂模式"></a>-p        设置接口为非混杂模式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p                        <span class="comment"># don't capture in promiscuous mode</span></span><br></pre></td></tr></table></figure><p><em>Don’t</em> put the interface into promiscuous mode. Note that the interface might be in promiscuous mode for some other reason; hence, <strong>-p</strong> cannot be used to ensure that the only traffic that is captured is traffic sent to or from the machine on which <strong>TShark</strong> is running, broadcast traffic, and multicast traffic to addresses received by that machine.</p><p>不让接口成为混杂模式。</p><p>This option can occur multiple times. If used before the first occurrence of the <strong>-i</strong> option, no interface will be put into the promiscuous mode. If used after an <strong>-i</strong> option, the interface specified by the last <strong>-i</strong> option occurring before this option will not be put into the promiscuous mode.</p><p>这个选项能出现多次。如果在第一次出现-i选项前使用，那么没有接口会被设置为混杂模式。如果在<strong>-i</strong>选项后被使用，那么在<strong>-p</strong>选项前的最后一个<strong>-i</strong>选项指定的接口将不会被设置为混杂模式。</p><h4 id="I-为IEEE802-11设置监控模式"><a href="#I-为IEEE802-11设置监控模式" class="headerlink" title="-I        为IEEE802.11设置监控模式"></a>-I        为IEEE802.11设置监控模式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-I                          <span class="comment"># capture in monitor mode, if available</span></span><br></pre></td></tr></table></figure><p>Put the interface in “monitor mode”; this is supported only on IEEE 802.11 Wi-Fi interfaces, and supported only on some operating systems.</p><p>设置为监控模式；这仅在IEEE802.11 Wi-Fi接口和某些操作系统上支持。</p><h4 id="B-设置捕获缓冲区大小"><a href="#B-设置捕获缓冲区大小" class="headerlink" title="-B        设置捕获缓冲区大小"></a>-B        设置捕获缓冲区大小</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-B &lt;buffer size&gt;                 <span class="comment"># size of kernel buffer (def: 4MB)</span></span><br></pre></td></tr></table></figure><p>Set capture buffer size (in MiB, default is 2 MiB). </p><p>设置捕获缓冲区大小，TSshark官方文档中说默认是2MB。在我这台Linux服务器显示是4MB</p><h4 id="y-设置数据链路类型"><a href="#y-设置数据链路类型" class="headerlink" title="-y        设置数据链路类型"></a>-y        设置数据链路类型</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-y &lt;link <span class="built_in">type</span>&gt;                 <span class="comment"># link layer type (def: first appropriate)</span></span><br></pre></td></tr></table></figure><p>Set the data link type to use while capturing packets. The values reported by <strong>-L</strong> are the values that can be used.</p><p>当在捕获数据包时，设置数据链路类型。能够使用的值在<strong>-L</strong>参数中被展示</p><p><img src="/2019/04/26/tshark使用方法/1553424590831.png" alt="1553424590831"></p><p><img src="/2019/04/26/tshark使用方法/1553424678354.png" alt="1553424678354"></p><p>This option can occur multiple times. If used before the first occurrence of the <strong>-i</strong> option, it sets the default capture link type. If used after an <strong>-i</strong> option, it sets the capture link type for the interface specified by the last <strong>-i</strong> option occurring before this option. If the capture link type is not set specifically, the default capture link type is used if provided.</p><h4 id="D-输出接口列表"><a href="#D-输出接口列表" class="headerlink" title="-D        输出接口列表"></a>-D        输出接口列表</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-D                        <span class="comment"># print list of interfaces and exit</span></span><br></pre></td></tr></table></figure><p><img src="/2019/04/26/tshark使用方法/1553424287090.png" alt="1553424287090"></p><h4 id="L-显示数据链路类型"><a href="#L-显示数据链路类型" class="headerlink" title="-L        显示数据链路类型"></a>-L        显示数据链路类型</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-L                        <span class="comment"># print list of link-layer types of iface and exit</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-2-Capture-stop-conditions-捕获停止选项"><a href="#3-2-Capture-stop-conditions-捕获停止选项" class="headerlink" title="3.2 Capture stop conditions:捕获停止选项"></a>3.2 Capture stop conditions:捕获停止选项</h3><h4 id="c-在N个数据包后停止捕获"><a href="#c-在N个数据包后停止捕获" class="headerlink" title="-c 在N个数据包后停止捕获"></a>-c 在N个数据包后停止捕获</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-c &lt;packet count&gt;         <span class="comment"># stop after n packets (def: infinite)</span></span><br></pre></td></tr></table></figure><p>Set the maximum number of packets to read when capturing live data. If reading a capture file, set the maximum number of packets to read.</p><p>在捕获实时数据时，设置一个最大的数据包读取数。如果是在读取捕获文件，依旧是要设置一个读取数据包的数量。第一张图是实时捕获的情况，第二张图是读取http_google.pcap文件只看前3个包的情况。</p><p><img src="/2019/04/26/tshark使用方法/1553424792984.png" alt="1553424792984"></p><h4 id="a-设置停止捕获条件"><a href="#a-设置停止捕获条件" class="headerlink" title="-a 设置停止捕获条件"></a>-a 设置停止捕获条件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a &lt;autostop cond.&gt; ...  </span><br><span class="line"></span><br><span class="line">​                           duration:NUM - stop after NUM seconds</span><br><span class="line">​                           filesize:NUM - stop this file after NUM KB</span><br><span class="line">​                           files:NUM - stop after NUM files</span><br></pre></td></tr></table></figure><p>Specify a criterion that specifies when <strong>TShark</strong> is to stop writing to a capture file. The criterion is of the form <strong><em>test:value</em></strong>, where <em>test</em> is one of:</p><p>指定一个标准，指定<strong>TShark</strong>何时停止写入捕获文件。标准的写法是test：value，其中test是以下之一</p><p><strong>duration</strong>:<em>value</em>   Stop writing to a capture file after <em>value</em> seconds have elapsed. Floating point values (e.g. 0.5) are allowed.</p><p><strong>duration</strong>:<em>value</em>    经过value秒后停止捕获文件。duration是持续时间的意思。浮点数值也是被允许的（比如0.5）。下图测试，确实在1s后停止捕获，同时还告诉你6个包被捕获到了</p><p><img src="/2019/04/26/tshark使用方法/1553424874791.png" alt="1553424874791"></p><p><strong>files</strong>:<em>value</em>        Stop writing to capture files after <em>value</em> number of files were written.</p><p><strong>files</strong>:<em>value</em>        在捕获value个文件后，就停止捕获</p><p><strong>filesize</strong>:<em>value</em>    Stop writing to a capture file after it reaches a size of <em>value</em> kB. If this option is used together with the -b option, <strong>TShark</strong> will stop writing to the current capture file and switch to the next one if filesize is reached. When reading a capture file, <strong>TShark</strong> will stop reading the file after the number of bytes read exceeds this number (the complete packet will be read, so more bytes than this number may be read). Note that the filesize is limited to a maximum value of 2 GiB.</p><p><strong>filesize</strong>:<em>value</em>    在达到value kB的大小后停止写入捕获文件。如果此选项与-b选项一起使用，则<strong>TShark</strong>将停止写入当前捕获文件，并在达到文件大小时切换到下一个文件。读取捕获文件时，<strong>TShark</strong>将在读取的字节数超过此数字后停止读取该文件（因为要读取完整数据包，所以可能会读取出超出这个数值的字节数）。请注意，文件大小限制为2 GiB。</p><p><img src="/2019/04/26/tshark使用方法/1553425008635.png" alt="1553425008635"></p><hr><h3 id="3-3-Capture-output-捕获输出"><a href="#3-3-Capture-output-捕获输出" class="headerlink" title="3.3 Capture output:捕获输出"></a>3.3 Capture output:捕获输出</h3><h4 id="b-设置循环写入多个数据包条件"><a href="#b-设置循环写入多个数据包条件" class="headerlink" title="-b 设置循环写入多个数据包条件"></a>-b 设置循环写入多个数据包条件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-b &lt;ringbuffer opt.&gt; ... </span><br><span class="line">​                            duration:NUM - switch to next file after NUM secs</span><br><span class="line">​                            filesize:NUM - switch to next file after NUM KB</span><br><span class="line">​                            files:NUM - ringbuffer: replace after NUM files</span><br></pre></td></tr></table></figure><p>Cause <strong>TShark</strong> to run in “multiple files” mode. In “multiple files” mode, <strong>TShark</strong> will write to several capture files. When the first capture file fills up, <strong>TShark</strong> will switch writing to the next file and so on.</p><p>导致<strong>TShark</strong>使用“多文件”模式运行。在“多文件”模式下，<strong>TShark</strong>将写入多个捕获文件。当第一个捕获文件写满，<strong>TShark</strong>将切换写入到下一个文件，以此类推。</p><p>The created filenames are based on the filename given with the <strong>-w</strong> option, the number of the file and on the creation date and time, e.g. outfile_00001_20190714120117.pcap, outfile_00002_20190714120523.pcap, …</p><p>被创建的这些文件名是基于<strong>-w</strong>选项所给出的“文件名，文件的编号以及在创建时的数据和时间”。例如 outfile_00001_20190714120117.pcap，outfile_00002_20190714120523.pcap, …</p><p>With the <em>files</em> option it’s also possible to form a “ring buffer”. This will fill up new files until the number of files specified, at which point <strong>TShark</strong> will discard the data in the first file and start writing to that file and so on. If the <em>files</em> option is not set, new files filled up until one of the capture stop conditions match (or until the disk is full).</p><p>使用files选项还可以形成“环形缓冲区”。这将填充新文件直到所指定的文件数。在这一点上，<strong>TShark</strong>将丢弃在第一个文件中的数据并开始把数据写入另一个文件中，以此类推。如果files选项没有被设置，则将填满新文件，直到其中一个捕获停止条件匹配为止（或是直到硬盘被填满）。</p><p>The criterion is of the form <em>key:value</em>, where <em>key</em> is one of:</p><p>标准格式是<em>key:value</em>，<em>key</em>是以下参数中的一个：</p><p><strong>duration</strong>:<em>value</em>   switch to the next file after <em>value</em> seconds have elapsed, even if the current file is not completely filled up. Floating point values (e.g. 0.5) are allowed.</p><p><strong>duration</strong>:<em>value</em>    在经过<em>value</em>秒后切换到下一个文件，即便现在的文件没有被完全填满。浮点数值（例如0.5）也是可以使用的。</p><p><img src="/2019/04/26/tshark使用方法/1553317134423.png" alt="1553317134423"></p><p><strong>files</strong>:<em>value</em>     begin again with the first file after <em>value</em> number of files were written (form a ring buffer). This value must be less than 100000. Caution should be used when using large numbers of files: some filesystems do not handle many files in a single directory well. The <strong>files</strong> criterion requires either <strong>duration</strong>, <strong>interval</strong> or <strong>filesize</strong> to be specified to control when to go to the next file. It should be noted that each <strong>-b</strong> parameter takes exactly one criterion; to specify two criterion, each must be preceded by the <strong>-b</strong> option.</p><p><strong>files</strong>:<em>value</em>    在<em>value</em>个文件数被写入后，再次从第一个文件开始（形成环形缓冲区）。这个数值必须小于100000。当使用大量的文件数时，需要谨慎使用：因为一些文件系统不能在当个的目录下处理好大量的文件。文件标准要求指定持续时间，间隔或文件大小以控制何时转到下一个文件。需要注意的是每个<strong>-b</strong>参数只使用一个标准；想要使用两个标准，那么每个标准前都要加上<strong>-b</strong>参数</p><p><img src="/2019/04/26/tshark使用方法/1553317668809.png" alt="1553317668809"></p><p><strong>filesize</strong>:<em>value</em>   switch to the next file after it reaches a size of <em>value</em> kB. Note that the filesize is limited to a maximum value of 2 GiB.</p><p><strong>filesize</strong>:<em>value</em>     在到达<em>value</em> kB后，切换到下一个文件。需要注意的是文件大小被限制在2GB以下。</p><hr><h3 id="3-4-Input-file-读取本地文件"><a href="#3-4-Input-file-读取本地文件" class="headerlink" title="3.4 Input file:读取本地文件"></a>3.4 Input file:读取本地文件</h3><h4 id="r"><a href="#r" class="headerlink" title="-r"></a>-r</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-r &lt;infile&gt;                  <span class="comment"># set the filename to read from (no stdin!)</span></span><br></pre></td></tr></table></figure><p><img src="/2019/04/26/tshark使用方法/1553318042410.png" alt="1553318042410"></p><hr><h3 id="3-5-Processing-处理过程"><a href="#3-5-Processing-处理过程" class="headerlink" title="3.5 Processing:处理过程"></a>3.5 Processing:处理过程</h3><h4 id="2-执行2次分析"><a href="#2-执行2次分析" class="headerlink" title="-2 执行2次分析"></a>-2 执行2次分析</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-2                           <span class="comment"># perform a two-pass analysis</span></span><br></pre></td></tr></table></figure><p>执行两次分析</p><h4 id="R-设置显示过滤器"><a href="#R-设置显示过滤器" class="headerlink" title="-R 设置显示过滤器"></a>-R 设置显示过滤器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-R &lt;<span class="built_in">read</span> filter&gt;             <span class="comment"># packet Read filter in Wireshark display filter syntax</span></span><br></pre></td></tr></table></figure><p>Cause the specified filter (which uses the syntax of read/display filters, rather than that of capture filters) to be applied during the first pass of analysis. Packets not matching the filter are not considered for future passes. Only makes sense with multiple passes, see -2. For regular filtering on single-pass dissect see -Y instead.</p><p>在第一遍分析中使用指定过滤器（该过滤器使用的是读取/显示过滤器的语法，而不是捕获过滤器的语法）。没有匹配过滤器的数据包将不会在后续展示。<strong>-R</strong>对于数据包进行多次分析才有意义，可以参考<strong>-2</strong>。对于单次的常规分析详见<strong>-Y</strong>。</p><h4 id="Y-设置显示过滤器（单次分析）"><a href="#Y-设置显示过滤器（单次分析）" class="headerlink" title="-Y 设置显示过滤器（单次分析）"></a>-Y 设置显示过滤器（单次分析）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Y &lt;display filter&gt;          <span class="comment"># packet displaY filter in Wireshark display filter syntax</span></span><br></pre></td></tr></table></figure><p>Cause the specified filter (which uses the syntax of read/display filters, rather than that of capture filters) to be applied before printing a decoded form of packets or writing packets to a file. Packets matching the filter are printed or written to file; packets that the matching packets depend upon (e.g., fragments), are not printed but are written to file; packets not matching the filter nor depended upon are discarded rather than being printed or written.</p><p>在输出数据包的解码形式或写入数据包到文件前，使用指定的过滤器（过滤器使用读取/显示过滤器的语法，而不是捕获过滤器）。匹配过滤的数据包将输出或是写入到文件；基于匹配的数据包（例如：数据段），将不会输出但是会写入到文件；不匹配过滤器的数据包被丢弃而不是被打印或写入。</p><p>Use this instead of -R for filtering using single-pass analysis. If doing two-pass analysis (see -2) then only packets matching the read filter (if there is one) will be checked against this filter.</p><p>对于过滤时使用-R将进行单次分析。如果做2次分析（见-2），那么只有数据包匹配了读取过滤器（如果有的话），将会针对这个过滤器再次检查。</p><h4 id="n-设置不做名称解析"><a href="#n-设置不做名称解析" class="headerlink" title="-n 设置不做名称解析"></a>-n 设置不做名称解析</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-n                           <span class="comment"># disable all name resolutions (def: all enabled)</span></span><br></pre></td></tr></table></figure><p>Disable network object name resolution (such as hostname, TCP and UDP port names); the <strong>-N</strong> option might override this one.</p><p>关闭所有名称解析（例如主机名，TCP和UDP的端口名）；<strong>-N</strong>选项将覆盖-n选项。</p><h4 id="N-设置只为特定情况做名称解析"><a href="#N-设置只为特定情况做名称解析" class="headerlink" title="-N 设置只为特定情况做名称解析"></a>-N 设置只为特定情况做名称解析</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-N &lt;name resolve flags&gt;      <span class="comment"># enable specific name resolution(s): "mnNtC"</span></span><br></pre></td></tr></table></figure><p>Turn on name resolving only for particular types of addresses and port numbers, with name resolving for other types of addresses and port numbers turned off. This option overrides <strong>-n</strong> if both <strong>-N</strong> and <strong>-n</strong> are present. If both <strong>-N</strong> and <strong>-n</strong> options are not present, all name resolutions are turned on.</p><p>只为特定的地址和端口号类型打开名称解析，对于没有指定的则不进行地址解析。如果<strong>-N</strong>和<strong>-n</strong>选项同时出现，则会覆盖<strong>-n</strong>选项。如果<strong>-N</strong>和<strong>-n</strong>选项都没出现，则名称解析会被开启。</p><p>The argument is a string that may contain the letters:</p><p>参数是包含以下字母的字符串</p><p><strong>d</strong> to enable resolution from captured DNS packets</p><p>从捕获的DNS数据包中开始解析</p><p><strong>m</strong> to enable MAC address resolution</p><p>开启MAC地址解析</p><p><strong>n</strong> to enable network address resolution</p><p>开启网络地址解析</p><p><strong>N</strong> to enable using external resolvers (e.g., DNS) for network address resolution</p><p>使用外部解析器（如DNS）来对网络地址进行解析</p><p><strong>t</strong> to enable transport-layer port number resolution</p><p>开启传输层端口号解析</p><p><strong>v</strong> to enable VLAN IDs to names resolution</p><p>开启VLAN ID的名称解析</p><h4 id="d-设置解码格式"><a href="#d-设置解码格式" class="headerlink" title="-d 设置解码格式"></a>-d 设置解码格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-d &lt;layer_type&gt;== &lt;selector&gt;,&lt;decode_as_protocol&gt; ...</span><br><span class="line">                             <span class="comment"># "Decode As", see the man page for details</span></span><br><span class="line">                             <span class="comment"># Example: tcp.port==8888,http</span></span><br></pre></td></tr></table></figure><p>Like Wireshark’s <strong>Decode As…</strong> feature, this lets you specify how a layer type should be dissected. If the layer type in question (for example, <strong>tcp.port</strong> or <strong>udp.port</strong> for a TCP or UDP port number) has the specified selector value, packets should be dissected as the specified protocol.</p><p>类似于Wireshark的<strong>Decode As…</strong>这个功能让你指定如何对每层类型进行分析。如果请求的层次类型（如TCP或是UDP端口号中的<strong>tcp.port</strong> 、<strong>udp.port</strong> ）有指定的选择值，则数据包将会使用指定的协议进行分析。</p><p>Example: <strong>tshark -d tcp.port==8888,http</strong> will decode any traffic running over TCP port 8888 as HTTP.</p><p>例如：<strong>tshark -d tcp.port==8888,http</strong>将会解码每一个TCP端口号是8888的流量为HTTP协议。</p><p>Example: <strong>tshark -d tcp.port==8888:3,http</strong> will decode any traffic running over TCP ports 8888, 8889 or 8890 as HTTP.</p><p>例如：<strong>tshark -d tcp.port==8888:3,http</strong>将会解码每一个TCP端口号是8888，8889,8890的流量为HTTP协议。</p><p>Example: <strong>tshark -d tcp.port==8888-8890,http</strong> will decode any traffic running over TCP ports 8888, 8889 or 8890 as HTTP.</p><p>含义同上，只是写法有区别</p><p>Using an invalid selector or protocol will print out a list of valid selectors and protocol names, respectively.</p><p>使用无效的解析器或协议将会分别打印出有效解析器和协议名称的表。</p><p>Example: <strong>tshark -d .</strong> is a quick way to get a list of valid selectors.</p><p>例如：<strong>tshark -d .</strong>以最快的方式列出有效解析器</p><p>Example: <strong>tshark -d ethertype==0x0800.</strong> is a quick way to get a list of protocols that can be selected with an ethertype.</p><p>例如：<strong>tshark -d ethertype==0x0800.</strong>以最快的方式获取能选择的以太网类型的协议列表</p><h4 id="H"><a href="#H" class="headerlink" title="-H"></a>-H</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-H &lt;hosts file&gt;         </span><br><span class="line">​            <span class="built_in">read</span> a list of entries from a hosts file, <span class="built_in">which</span> will  <span class="keyword">then</span> be written to a capture file. (Implies -W n)</span><br></pre></td></tr></table></figure><p>Read a list of entries from a “hosts” file, which will then be written to a capture file. Implies <strong>-W n</strong>. Can be called multiple times.</p><p>从“hosts”文件中读取条目列表，然后将其写入捕获文件。也可以使用<strong>-W n</strong>。可以多次调用。</p><hr><h3 id="3-6-Output-输出"><a href="#3-6-Output-输出" class="headerlink" title="3.6 Output:输出"></a>3.6 Output:输出</h3><h4 id="w-写入文件"><a href="#w-写入文件" class="headerlink" title="-w  写入文件"></a>-w  写入文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-w &lt;outfile|-&gt;               <span class="comment"># write packets to a pcap-format file named "outfile"</span></span><br><span class="line">                             <span class="comment"># (or to the standard output for "-")</span></span><br></pre></td></tr></table></figure><p>Write raw packet data to <em>outfile</em> or to the standard output if <em>outfile</em> is ‘-‘.</p><p>在标准输出或是输出文件中写入原始数据包</p><p>NOTE: -w provides raw packet data, not text. If you want text output you need to redirect stdout (e.g. using ‘&gt;’), don’t use the <strong>-w</strong> option for this.</p><p>注意：<strong>-w</strong>提供的是原始数据包，而非文本。如果你想输出文本，你需要重定向（例如使用‘&gt;’），而非使用-w选项。</p><h4 id="F-设置写入文件格式"><a href="#F-设置写入文件格式" class="headerlink" title="-F  设置写入文件格式"></a>-F  设置写入文件格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-F &lt;output file <span class="built_in">type</span>&gt;        <span class="comment"># set the output file type, default is pcapng</span></span><br><span class="line">                             <span class="comment"># an empty "-F" option will list the file types</span></span><br></pre></td></tr></table></figure><p>Set the file format of the output capture file written using the <strong>-w</strong> option. The output written with the <strong>-w</strong> option is raw packet data, not text, so there is no <strong>-F</strong> option to request text output. The option <strong>-F</strong> without a value will list the available formats.</p><p>使用<strong>-w</strong>选项设置输出捕获文件写入的文件格式。使用<strong>-w</strong>选项写入的输出是原始数据包而非文本。<strong>-F</strong>选项后不接值，则将列出可获得的格式。</p><h4 id="V（大写V，显示数据包细节）"><a href="#V（大写V，显示数据包细节）" class="headerlink" title="-V（大写V，显示数据包细节）"></a>-V（大写V，显示数据包细节）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-V                           <span class="comment"># add output of packet tree (Packet Details)</span></span><br></pre></td></tr></table></figure><p>Cause <strong>TShark</strong> to print a view of the packet details.</p><p><img src="/2019/04/26/tshark使用方法/1553425274015.png" alt="1553425274015"></p><h4 id="O-显示此选项指定的协议的详细信息"><a href="#O-显示此选项指定的协议的详细信息" class="headerlink" title="-O 显示此选项指定的协议的详细信息"></a>-O 显示此选项指定的协议的详细信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-O &lt;protocols&gt;               <span class="comment"># Only show packet details of these protocols, comma                                        separated</span></span><br></pre></td></tr></table></figure><p>Similar to the <strong>-V</strong> option, but causes <strong>TShark</strong> to only show a detailed view of the comma-separated list of <em>protocols</em> specified, and show only the top-level detail line for all other protocols, rather than a detailed view of all protocols. Use the output of “<strong>tshark -G protocols</strong>“ to find the abbreviations of the protocols you can specify.</p><p>类似于<strong>-V</strong>，只是<strong>TShark</strong>仅显示指定协议的以逗号分隔开的协议细节。同时仅为其他的协议显示顶层细节行，而非全体细节。使用 “<strong>tshark -G protocols</strong>“ 你可以获得可以指定的协议列表。</p><h4 id="T-与-e一起使用，显示相应的特定内容"><a href="#T-与-e一起使用，显示相应的特定内容" class="headerlink" title="-T 与-e一起使用，显示相应的特定内容"></a>-T 与-e一起使用，显示相应的特定内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-T pdml|ps|psml|text|fields  <span class="comment"># format of text output (def: text)</span></span><br></pre></td></tr></table></figure><p>Set the format of the output when viewing decoded packet data. The options are one of:</p><p>当在查看解码数据包数据时设置输出格式。选项可以为以下之一（我只列出常用的）：</p><p><strong>fields</strong> The values of fields specified with the <strong>-e</strong> option, in a form specified by the <strong>-E</strong> option. For example,</p><p><strong>fields</strong>  使用<strong>-e</strong>选项指定字段的值，采用-E选项指定格式。例如，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tshark -T fields -E separator=, -E quote=d</span><br></pre></td></tr></table></figure><p><img src="/2019/04/26/tshark使用方法/1553425343018.png" alt="1553425343018"></p><h4 id="e"><a href="#e" class="headerlink" title="-e"></a>-e</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-e &lt;field&gt;                   <span class="comment"># field to print if -Tfields selected (e.g. tcp.port,                                      col.Info);this option can be repeated to print multiple                                  fields</span></span><br></pre></td></tr></table></figure><p>Add a field to the list of fields to display if <strong>-T ek|fields|json|pdml</strong> is selected. This option can be used multiple times on the command line. At least one field must be provided if the <strong>-T fields</strong> option is selected. </p><p>如果选择了<strong>-T ek|fields|json|pdml</strong>，则添加一个字段来显示字段列表。在命令行，这个选项可以使用多次。如果使用的是 <strong>-T fields</strong> ，则至少要提供一个字段。</p><p>Example: <strong>tshark -e frame.number -e ip.addr -e udp </strong></p><p>例如：<strong>tshark -e frame.number -e ip.addr -e udp </strong></p><p>Giving a protocol rather than a single field will print multiple items of data about the protocol as a single field. Fields are separated by tab characters by default. <strong>-E</strong> controls the format of the printed fields.</p><p>给定一个协议而不是单个字段，将会打印出这个协议作为单个字段的多个项目数据。字段默认情况下会被制表符分隔。<strong>-E</strong>控制打印字段的格式。</p><h4 id="E-设置控制字段打印的选项"><a href="#E-设置控制字段打印的选项" class="headerlink" title="-E 设置控制字段打印的选项"></a>-E 设置控制字段打印的选项</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-E&lt;fieldsoption&gt;=&lt;value&gt;     <span class="comment"># set options for output when -Tfields selected:</span></span><br><span class="line">     header=y|n                 switch headers on and off</span><br><span class="line">     separator=/t|/s|&lt;char&gt;     select tab, space, printable character as separator</span><br><span class="line">     occurrence=f|l|a           <span class="built_in">print</span> first, last or all occurrences of each field</span><br><span class="line">     aggregator=,|/s|&lt;char&gt;     select comma, space, printable character as  aggregator</span><br><span class="line">     quote=d|s|n                select double, single, no quotes <span class="keyword">for</span> values</span><br></pre></td></tr></table></figure><h4 id="t-设置时间显示格式"><a href="#t-设置时间显示格式" class="headerlink" title="-t 设置时间显示格式"></a>-t 设置时间显示格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-t a|ad|d|dd|e|r|u|ud        <span class="comment"># output format of time stamps (def: r: rel. to first)</span></span><br></pre></td></tr></table></figure><h4 id="u-设置秒的类型"><a href="#u-设置秒的类型" class="headerlink" title="-u  设置秒的类型"></a>-u  设置秒的类型</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-u s|hms                     <span class="comment"># output format of seconds (def: s: seconds)</span></span><br></pre></td></tr></table></figure><p>Specifies the seconds type. Valid choices are:</p><p><strong>s</strong> for seconds</p><p><strong>hms</strong> for hours, minutes and seconds</p><h4 id="W-n"><a href="#W-n" class="headerlink" title="-W n"></a>-W n</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-W n                         <span class="comment"># Save extra information in the file, if supported.</span></span><br><span class="line">                             <span class="comment"># n = write network address resolution information</span></span><br></pre></td></tr></table></figure><p>Save extra information in the file if the format supports it. For example,</p><p>如果格式支持，则保存额外的信息到文件中。例如，使用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tshark -F pcapng -W n</span><br></pre></td></tr></table></figure><p>will save host name resolution records along with captured packets.</p><p>则将保存主机名称解析的解码到捕获数据包中。</p><p>Future versions of <strong>Tshark</strong> may automatically change the capture format to <strong>pcapng</strong> as needed.</p><p>未来版本的<strong>Tshark</strong>可能会根据需要自动将捕获格式更改为pcapng。</p><p>The argument is a string that may contain the following letter:</p><p><strong>n</strong> write network address resolution information (pcapng only)</p><p>参数可以是以下的字符串：</p><p><strong>n</strong> 写入网络地址解析信息(仅限pcapng)</p><h4 id="q与-z-获取各种统计信息（只挑选了部分常用的）"><a href="#q与-z-获取各种统计信息（只挑选了部分常用的）" class="headerlink" title="-q与-z 获取各种统计信息（只挑选了部分常用的）"></a>-q与-z 获取各种统计信息（只挑选了部分常用的）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-q                           <span class="comment"># be more quiet on stdout (e.g. when using statistics)</span></span><br><span class="line">-z &lt;statistics&gt;              <span class="comment"># various statistics, see the man page for details</span></span><br></pre></td></tr></table></figure><p>Get <strong>TShark</strong> to collect various types of statistics and display the result after finishing reading the capture file. Use the <strong>-q</strong> option if you’re reading a capture file and only want the statistics printed, not any per-packet information.</p><p>让<strong>TShark</strong>收集统计的各种类型，并且在完成读取的捕获文件后展示出来。如果你正在读取捕获文件，并只想打印出统计信息，而不是每个包的信息，则使用<strong>-q</strong>选项。</p><p>Note that the <strong>-z proto</strong> option is different - it doesn’t cause statistics to be gathered and printed when the capture is complete, it modifies the regular packet summary output to include the values of fields specified with the option. Therefore you must not use the <strong>-q</strong> option, as that option would suppress the printing of the regular packet summary output, and must also not use the <strong>-V</strong> option, as that would cause packet detail information rather than packet summary information to be printed.</p><p>注意的是<strong>-z proto</strong>有不同之处。当在捕获完成时，它不会收集统计信息并打印出来，而是修改常规数据包汇总输出，包括选项中指定字段的数值。因此，你不能使用<strong>-q</strong>选项，因为该选项会禁止打印常规数据包的汇总输出。同时，也不能使用<strong>-V</strong>选项，因为这会导致数据包的细节信息被打印出来，而非数据包的汇总信息。</p><p>Currently implemented statistics are:目前实现的统计有如下内容：</p><ul><li><p><strong>-z help</strong></p><p>Display all possible values for <strong>-z</strong>.</p><p>显示所有可能的数值</p></li></ul><ul><li><p><strong>-z afp,srt[,<em>filter</em>]</strong></p><p>Show Apple Filing Protocol service response time statistics.</p><p>显示AFP服务器响应时间统计</p></li></ul><ul><li><p><strong>-z conv,<em>type</em>[,<em>filter</em>]</strong></p><p>Create a table that lists all conversations that could be seen in the capture. <em>type</em> specifies the conversation endpoint types for which we want to generate the statistics; currently the supported ones are:</p><p>创建一个表，里面包含了所有统计信息，这些信息可以在捕获中看到。<em>type</em>指定了我们想要生成的统计信息的会话终端类型。目前支持的内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"bluetooth"</span>               Bluetooth addresses</span><br><span class="line"><span class="string">"eth"</span>                     Ethernet addresses</span><br><span class="line"><span class="string">"fc"</span>                      Fibre Channel addresses</span><br><span class="line"><span class="string">"fddi"</span>                    FDDI addresses</span><br><span class="line"><span class="string">"ip"</span>                      IPv4 addresses</span><br><span class="line"><span class="string">"ipv6"</span>                    IPv6 addresses</span><br><span class="line"><span class="string">"ipx"</span>                     IPX addresses</span><br><span class="line"><span class="string">"jxta"</span>                    JXTA message addresses</span><br><span class="line"><span class="string">"ncp"</span>                     NCP connections</span><br><span class="line"><span class="string">"rsvp"</span>                    RSVP connections</span><br><span class="line"><span class="string">"sctp"</span>                    SCTP addresses</span><br><span class="line"><span class="string">"tcp"</span>                     TCP/IP socket pairs  Both IPv4 and IPv6 are supported</span><br><span class="line"><span class="string">"tr"</span>                      Token Ring addresses</span><br><span class="line"><span class="string">"usb"</span>                     USB addresses</span><br><span class="line"><span class="string">"udp"</span>                     UDP/IP socket pairs  Both IPv4 and IPv6 are supported</span><br><span class="line"><span class="string">"wlan"</span>                    IEEE 802.11 addresses</span><br></pre></td></tr></table></figure><p>If the optional <em>filter</em> is specified, only those packets that match the filter will be used in the calculations.</p><p>如果指定了<em>filter</em>，则在计算时会使用匹配了过滤条件的这些数据包。</p><p>The table is presented with one line for each conversation and displays the number of packets/bytes in each direction as well as the total number of packets/bytes. The table is sorted according to the total number of frames.</p><p>这个表会为每个会话显示一行，并且显示每个方向的数据包/字节的数目及其总数。该表会依据数据帧数进行排序。</p><p><img src="/2019/04/26/tshark使用方法/1553419331871.png" alt="1553419331871"></p></li></ul><ul><li><p><strong>-z bootp,stat[,<em>filter</em>]</strong></p><p>Show DHCP (BOOTP) statistics.</p><p>显示DHCP统计信息</p></li></ul><ul><li><p><strong>-z dns,tree[,<em>filter</em>]</strong></p><p>Create a summary of the captured DNS packets. General information are collected such as qtype and qclass distribution. For some data (as qname length or DNS payload) max, min and average values are also displayed.</p><p>为捕获的DNS数据包创建一个汇总。核心信息包含了如qtype，qclass distribution。对于一些数据（如qname长度或是DNS负载）的最大，最小，平均值也会被显示出来。</p></li></ul><ul><li><p><strong>-z endpoints,<em>type</em>[,<em>filter</em>]</strong></p><p>Create a table that lists all endpoints that could be seen in the capture. <em>type</em> specifies the endpoint types for which we want to generate the statistics; currently the supported ones are:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"bluetooth"</span>               Bluetooth addresses</span><br><span class="line"><span class="string">"eth"</span>                     Ethernet addresses</span><br><span class="line"><span class="string">"fc"</span>                      Fibre Channel addresses</span><br><span class="line"><span class="string">"fddi"</span>                    FDDI addresses</span><br><span class="line"><span class="string">"ip"</span>                      IPv4 addresses</span><br><span class="line"><span class="string">"ipv6"</span>                    IPv6 addresses</span><br><span class="line"><span class="string">"ipx"</span>                     IPX addresses</span><br><span class="line"><span class="string">"jxta"</span>                    JXTA message addresses</span><br><span class="line"><span class="string">"ncp"</span>                     NCP connections</span><br><span class="line"><span class="string">"rsvp"</span>                    RSVP connections</span><br><span class="line"><span class="string">"sctp"</span>                    SCTP addresses</span><br><span class="line"><span class="string">"tcp"</span>                     TCP/IP socket pairs  Both IPv4 and IPv6 are supported</span><br><span class="line"><span class="string">"tr"</span>                      Token Ring addresses</span><br><span class="line"><span class="string">"usb"</span>                     USB addresses</span><br><span class="line"><span class="string">"udp"</span>                     UDP/IP socket pairs  Both IPv4 and IPv6 are supported</span><br><span class="line"><span class="string">"wlan"</span>                    IEEE 802.11 addresses</span><br></pre></td></tr></table></figure><p>If the optional <em>filter</em> is specified, only those packets that match the filter will be used in the calculations（计算）.The table is presented with one line for each conversation and displays the number of packets/bytes in each direction as well as the total number of packets/bytes. The table is sorted according to the total number of frames.</p><p>与<strong>-z conv,<em>type</em>[,<em>filter</em>]</strong>类似</p></li></ul><ul><li><p><strong>-z expert [<em>,error|,warn|,note|,chat|,comment</em>][<em>,filter</em>]</strong></p><p>Collects information about all expert info, and will display them in order, grouped by severity.</p><p>Example: <strong>-z expert,sip</strong> will show expert items of all severity for frames that match the sip protocol.</p><p>This option can be used multiple times on the command line.</p><p>收集所有的expert info专家信息，并按顺序及重要性分组来显示他们。</p><p>例如: <strong>-z expert,sip</strong> 将显示与sip协议匹配的帧的所有重要专家项。</p></li></ul><p>  If the optional <em>filter</em> is provided, the stats will only be calculated on those calls that match that filter.</p><p>  Example: <strong>-z “expert,note,tcp”</strong> will only collect expert items for frames that include the tcp protocol, with a severity of note or higher.</p><p>  如果提供了<em>filter</em>，则只会根据与该过滤器匹配的调用计算统计信息。</p><p>  例如：<strong>-z “expert,note,tcp”</strong> 将仅收集note或更高层级的包含了tcp协议的数据帧的专家项</p><p>  <img src="/2019/04/26/tshark使用方法/1553419674561.png" alt="1553419674561"></p><ul><li><p><strong>-z flow,<em>name</em>,<em>mode</em>,[<em>filter</em>]</strong></p><p>Displays the flow of data between two nodes. Output is the same as ASCII format saved from GUI.</p><p><em>name</em> specifies the flow name. It can be one of:</p><p>显示在两端的数据流。输出与从GUI保存的ASCII格式相同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">any         All frames</span><br><span class="line">icmp        ICMP</span><br><span class="line">icmpv6      ICMPv6</span><br><span class="line">lbm_uim     UIM</span><br><span class="line">tcp         TCP</span><br></pre></td></tr></table></figure><p><em>mode</em> specifies the address type. It can be one of:</p><p><em>mode</em> 指定了地址类型。可以是以下之一</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">standard    Any address</span><br><span class="line">network     Network address</span><br></pre></td></tr></table></figure><p>Example: <strong>-z flow,tcp,network</strong> will show data flow for all TCP frame</p><p>例如： <strong>-z flow,tcp,network</strong>将展示所有TCP帧的数据流</p></li></ul><ul><li><p><strong>-z follow,<em>prot</em>,<em>mode</em>,<em>filter</em>[<em>,range</em>]</strong></p><p>Displays the contents of a TCP or UDP stream between two nodes. </p><p>展示在两端的TCP或是UDP流的内容。</p><p><em>prot</em> specifies the transport protocol. It can be one of:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcp     TCP</span><br><span class="line">udp     UDP</span><br><span class="line">tls     TLS or SSL</span><br></pre></td></tr></table></figure><p><em>mode</em> specifies the output mode. It can be one of:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ascii    ASCII output with dots <span class="keyword">for</span> non-printable characters</span><br><span class="line">ebcdic   EBCDIC output with dots <span class="keyword">for</span> non-printable characters</span><br><span class="line">hex      Hexadecimal and ASCII data with offsets</span><br><span class="line">raw      Hexadecimal data</span><br></pre></td></tr></table></figure></li></ul><p>  <em>filter</em> specifies the stream to be displayed. UDP/TCP streams are selected with either the stream index or IP address plus port pairs. TLS streams are selected with the stream index. For example:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip-addr0:port0,ip-addr1:port1</span><br><span class="line">stream-index</span><br></pre></td></tr></table></figure><p>  <em>range</em> optionally specifies which “chunks” of the stream should be displayed.</p><p>  Example: <strong>-z “follow,tcp,hex,1”</strong> will display the contents of the second TCP stream (the first is stream 0) in “hex” format.</p><p>  例如： <strong>-z “follow,tcp,hex,1”</strong>将会使用“hex”格式展示第二个TCP流的内容（第一个是stream 0）</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; ===================================================================</span><br><span class="line">&gt; Follow: tcp,hex</span><br><span class="line">&gt; Filter: tcp.stream eq 1</span><br><span class="line">&gt; Node 0: 200.57.7.197:32891</span><br><span class="line">&gt; Node 1: 200.57.7.198:2906</span><br><span class="line">&gt; 00000000  00 00 00 22 00 00 00 07  00 0a 85 02 07 e9 00 02  ...&quot;.... ........</span><br><span class="line">&gt; 00000010  07 e9 06 0f 00 0d 00 04  00 00 00 01 00 03 00 06  ........ ........</span><br><span class="line">&gt; 00000020  1f 00 06 04 00 00                                 ......</span><br><span class="line">&gt; 00000000  00 01 00 00                                       ....</span><br><span class="line">&gt; 00000026  00 02 00 00</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>  <img src="/2019/04/26/tshark使用方法/1553425530931.png" alt="1553425530931"></p><p>  Example: <strong>-z “follow,tcp,ascii,200.57.7.197:32891,200.57.7.198:2906”</strong> will display the contents of a TCP stream between 200.57.7.197 port 32891 and 200.57.7.98 port 2906.</p><p>  例如：<strong>-z “follow,tcp,ascii,200.57.7.197:32891,200.57.7.198:2906”</strong>将会展示200.57.7.197的32891端口与200.57.7.98的2906端口的TCP流的内容</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; ===================================================================</span><br><span class="line">&gt; Follow: tcp,ascii</span><br><span class="line">&gt; Filter: (omitted for readability)</span><br><span class="line">&gt; Node 0: 200.57.7.197:32891</span><br><span class="line">&gt; Node 1: 200.57.7.198:2906</span><br><span class="line">&gt; 38</span><br><span class="line">&gt; ...&quot;.....</span><br><span class="line">&gt; ................</span><br><span class="line">&gt; 4</span><br><span class="line">&gt; ....</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><strong>-z hosts [,ipv4][,ipv6]</strong></p><p>Dump any collected IPv4 and/or IPv6 addresses in “hosts” format. Both IPv4 and IPv6 addresses are dumped by default.Addresses are collected from a number of sources, including standard “hosts” files and captured traffic.</p></li></ul><ul><li><p><strong>-z http,stat,</strong></p><p>Calculate the HTTP statistics distribution. Displayed values are the HTTP status codes and the HTTP request methods.</p><p><img src="/2019/04/26/tshark使用方法/1553418861258.png" alt="1553418861258"></p></li></ul><ul><li><p><strong>-z</strong> http,tree</p><p>Calculate the HTTP packet distribution. Displayed values are the HTTP request modes and the HTTP status codes.</p><p><img src="/2019/04/26/tshark使用方法/1553418910684.png" alt="1553418910684"></p></li></ul><ul><li><p><strong>-z http_srv,tree</strong></p><p>Calculate the HTTP requests and responses by server. For the HTTP requests, displayed values are the server IP address and server hostname. For the HTTP responses, displayed values are the server IP address and status.</p><p><img src="/2019/04/26/tshark使用方法/1553419156361.png" alt="1553419156361"></p></li></ul><ul><li><p><strong>-z</strong> icmp,srt[,<em>filter</em>]</p><p>Compute total ICMP echo requests, replies, loss, and percent loss, as well as minimum, maximum, mean, median and sample standard deviation SRT statistics typical of what ping provides.</p><p>Example: <strong>-z icmp,srt,ip.src==1.2.3.4</strong> will collect ICMP SRT statistics for ICMP echo request packets originating from a specific host.This option can be used multiple times on the command line.</p><p>计算总的ICMP回应请求，回复，丢失和百分比损失，以及ping提供的典型的最小值，最大值，平均值，中值和样本标准差SRT统计量。</p><p>例如：<strong>-z icmp,srt,ip.src==1.2.3.4</strong>将收集源自特定主机的ICMP回送请求数据包的ICMP SRT统计信息。可以在命令行上多次使用此选项。</p><p><img src="/2019/04/26/tshark使用方法/1553420285309.png" alt="1553420285309"></p></li></ul><ul><li><p><strong>-z io,phs[,<em>filter</em>]</strong></p><p>Create Protocol Hierarchy Statistics listing both number of packets and bytes. If no <em>filter</em> is specified the statistics will be calculated for all packets. If a <em>filter</em> is specified statistics will only be calculated for those packets that match the filter.This option can be used multiple times on the command line.</p><p>创建一个包含所有数据包和字节数的协议分层信息列表。</p><p><img src="/2019/04/26/tshark使用方法/1553420404357.png" alt="1553420404357"></p></li></ul><ul><li><p><strong>-z io,stat,<em>interval</em>[,<em>filter</em>][,<em>filter</em>][,<em>filter</em>]…</strong></p><p>Collect packet/bytes statistics for the capture in intervals of <em>interval</em> seconds. <em>Interval</em> can be specified either as a whole or fractional second and can be specified with microsecond (us) resolution. If <em>interval</em> is 0, the statistics will be calculated over all packets.</p><p>按时间间隔秒数收集捕获的数据包/字节数统计信息。时间间隔可以指定为整数或小数秒，并且可以使用微秒（us）。如果<em>interval</em>为0，则将计算所有数据包的统计信息。</p></li></ul><p>  If no <em>filter</em> is specified the statistics will be calculated for all packets.If one or more <em>filters</em> are specified statistics will be calculated for all filters and presented with one column of statistics for each filter.</p><p>  This option can be used multiple times on the command line.</p><p>  如果没有指定过滤条件，则计算所有数据包的统计信息。如果一个或多个过滤条件被指定，那么会为所有的过滤条件来计算统计信息，并为每个过滤条件显示一列统计信息。可以在命令行上多次使用此选项。</p><p>  Example: <strong>-z io,stat,1,ip.addr==1.2.3.4</strong> will generate 1 second statistics for all traffic to/from host 1.2.3.4.</p><p>  例如： <strong>-z io,stat,1,ip.addr==1.2.3.4</strong> 将为所有进出主机1.2.3.4的流量生成1秒的统计信息</p><p>  Example: <strong>-z “io,stat,0.001,smb&amp;&amp;ip.addr==1.2.3.4”</strong> will generate 1ms statistics for all SMB packets to/from host 1.2.3.4.</p><p>  例如： <strong>-z io,stat,1,smb&amp;&amp;ip.addr==1.2.3.4</strong> 将为所有进出主机1.2.3.4的SMB流量生成1毫秒的统计信息</p><p>  The examples above all use the standard syntax for generating statistics which only calculates the number of packets and bytes in each interval.</p><p>  上面的示例都使用标准语法来生成统计信息，该统计信息仅计算每个间隔中的数据包和字节数。</p><p>  <img src="/2019/04/26/tshark使用方法/1553422202759.png" alt="1553422202759"></p><p>  <img src="/2019/04/26/tshark使用方法/1553422247214.png" alt="1553422247214"></p><ul><li><p><strong>-z io,stat,<em>interval</em>,”[COUNT|SUM|MIN|MAX|AVG|LOAD](<em>field</em>)<em>filter</em>“</strong></p><p><strong>io,stat</strong> can also do much more statistics and calculate COUNT(), SUM(), MIN(), MAX(), AVG() and LOAD() using a slightly different filter syntax:</p><p><strong>io,stat</strong>还能做更多的统计和计算。如COUNT(), SUM(), MIN(), MAX(), AVG() and LOAD()，这些使用稍微不同的过滤器语法。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tshark使用方法&quot;&gt;&lt;a href=&quot;#tshark使用方法&quot; class=&quot;headerlink&quot; title=&quot;tshark使用方法&quot;&gt;&lt;/a&gt;tshark使用方法&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.wireshark.org/doc
      
    
    </summary>
    
      <category term="linux" scheme="https://dilidonglong.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>使用github+hexo创建一个博客</title>
    <link href="https://dilidonglong.github.io/2019/04/25/%E4%BD%BF%E7%94%A8github-hexo%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://dilidonglong.github.io/2019/04/25/使用github-hexo创建一个博客/</id>
    <published>2019-04-25T07:01:58.000Z</published>
    <updated>2019-04-25T09:08:11.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用github-hexo创建一个博客"><a href="#使用github-hexo创建一个博客" class="headerlink" title="使用github+hexo创建一个博客"></a>使用github+hexo创建一个博客</h1><p>github建库过程略</p><p>在Windows系统下，要使用hexo需要先安装Nodejs以及Git</p><h2 id="1-安装Nodejs"><a href="#1-安装Nodejs" class="headerlink" title="1.安装Nodejs"></a>1.安装Nodejs</h2><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Nodejs下载地址</a>，下载之后，一路默认安装</p><p><img src="/2019/04/25/使用github-hexo创建一个博客/Nodejs.png" alt="官网图片"></p><h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h2><p><a href="https://gitforwindows.org/" target="_blank" rel="noopener">Git下载地址</a>，下载之后又是一路安装</p><p><img src="/2019/04/25/使用github-hexo创建一个博客/Git.png" alt="Git官网"></p><h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h2><h3 id="3-1创建一个文件夹"><a href="#3-1创建一个文件夹" class="headerlink" title="3.1创建一个文件夹"></a>3.1创建一个文件夹</h3><p>创建一个文件夹，比如hexo。来存放数据(这个blog不用管，是后面初始化后自动创建的)</p><p><img src="/2019/04/25/使用github-hexo创建一个博客/mkdir.png" alt="创建文件夹"></p><p>在这个目录下右键，选择红框所示内容。之后会弹出一个框，里面使用的是bash命令。</p><p><img src="/2019/04/25/使用github-hexo创建一个博客/gitbash.png" alt="gitbash"></p><p><img src="/2019/04/25/使用github-hexo创建一个博客/bash.png" alt="bash"></p><h3 id="3-2安装过程"><a href="#3-2安装过程" class="headerlink" title="3.2安装过程"></a>3.2安装过程</h3><p>在界面中输入下面内容，关于指令含义参考：<a href="https://hexo.io/zh-cn/docs/commands.html#generate" target="_blank" rel="noopener">Hexo-指令</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> d:/hexo</span><br><span class="line">$ npm install hexo-cli -g </span><br><span class="line">$ hexo init blog             <span class="comment">#初始化一个文件夹，命名为blog</span></span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo g                     <span class="comment"># 或者hexo generate</span></span><br><span class="line">$ hexo s                     <span class="comment"># 或者hexo server，可以在http://localhost:4000/ 查看</span></span><br></pre></td></tr></table></figure><blockquote><p>经常使用的命令：</p><ol><li>hexo generate (hexo g)                生成静态文件，会在当前目录下生成一个新的叫做public的文件夹</li><li>hexo server (hexo s)                     启动本地web服务，用于博客的预览</li><li>hexo deploy (hexo d)                    部署播客到远端（比如github, heroku等平台）</li><li>hexo new “postName”                  新建文章，postname指创建的文件名，文件会放在source\ _posts\下</li><li>hexo new page “pageName”        新建页面，pagename指创建的网页文件夹名，文件夹放在source\下</li></ol></blockquote><h3 id="3-3更换主题"><a href="#3-3更换主题" class="headerlink" title="3.3更换主题"></a>3.3更换主题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean          <span class="comment">#清除缓存文件 (db.json) 和已生成的静态文件 (public)。</span></span><br><span class="line">                      <span class="comment">#在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需                       #要运行该命令</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/zhwangart/hexo-theme-ocean.git themes/ocean</span><br></pre></td></tr></table></figure><h4 id="3-3-1使用主题"><a href="#3-3-1使用主题" class="headerlink" title="3.3.1使用主题"></a>3.3.1使用主题</h4><p>修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为ocean。</p><p><img src="/2019/04/25/使用github-hexo创建一个博客/theme.png" alt="theme"></p><h4 id="3-3-2更新主题"><a href="#3-3-2更新主题" class="headerlink" title="3.3.2更新主题"></a>3.3.2更新主题</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> themes/ocean</span><br><span class="line">$ git pull</span><br><span class="line">$ <span class="built_in">cd</span> ..</span><br><span class="line">$ hexo g                <span class="comment"># 生成</span></span><br><span class="line">$ hexo s                <span class="comment"># 启动本地web服务器</span></span><br></pre></td></tr></table></figure><h2 id="4-使用hexo-deploy部署"><a href="#4-使用hexo-deploy部署" class="headerlink" title="4.使用hexo deploy部署"></a>4.使用hexo deploy部署</h2><p><a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener">部署命令说明</a></p><h3 id="4-1扩展安装"><a href="#4-1扩展安装" class="headerlink" title="4.1扩展安装"></a>4.1扩展安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="4-2修改配置"><a href="#4-2修改配置" class="headerlink" title="4.2修改配置"></a>4.2修改配置</h3><p><img src="/2019/04/25/使用github-hexo创建一个博客/deployer.png" alt="deploy"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span><span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span><span class="attr">https://github.com/dilidonglong/dilidonglong.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span><span class="string">master</span></span><br></pre></td></tr></table></figure><h3 id="4-3完成部署"><a href="#4-3完成部署" class="headerlink" title="4.3完成部署"></a>4.3完成部署</h3><p>然后在命令行中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d              <span class="comment">#部署之前预先生成静态文件</span></span><br></pre></td></tr></table></figure><p>即可完成部署。</p><h3 id="4-4其他注意事项"><a href="#4-4其他注意事项" class="headerlink" title="4.4其他注意事项"></a>4.4其他注意事项</h3><p>上述命令虽然简单方便，但是偶尔会有莫名其妙的问题出现，因此，我们也可以追本溯源，使用git命令来完成部署的工作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> d:/hexo/blog</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/dilidonglong/dilidonglong.github.io.git .deploy/dilidonglong.github.io</span><br></pre></td></tr></table></figure><p>将我们之前创建的仓库克隆到本地，新建一个目录叫做.deploy用于存放克隆的代码。前提是这个库里面有你之前上传上去的内容。</p><p>接下来创建一个deploy脚本文件，比如可以取名叫deploy.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">cp -R public/* .deploy/dilidonglong.github.io</span><br><span class="line">cd .deploy/dilidonglong.github.io</span><br><span class="line">git add .</span><br><span class="line">git commit -m “update”</span><br><span class="line">git pull --rebase origin master</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>简单解释一下，hexo generate（hexo g）生成public文件夹下的新内容，然后将其拷贝至dilidonglong.github.io的git目录下，然后使用git commit命令提交代码到dilidonglong.github.io这个repo的master branch上。</p><p>需要部署的时候，执行这段脚本就可以了（比如可以将其保存为deploy.sh）。执行过程中可能需要让你输入Github账户的用户名及密码，按照提示操作即可。执行时，等同linux命令行：<code>./deploy.sh</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin master</span><br><span class="line">对于这条命令，是为了解决git push错误failed to push some refs to的问题</span><br></pre></td></tr></table></figure><p>上述问题的<a href="https://blog.csdn.net/MBuger/article/details/70197532" target="_blank" rel="noopener">参考链接</a></p><blockquote><p>参考文章：</p><p><a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">手把手教你使用Hexo + Github Pages搭建个人独立博客</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用github-hexo创建一个博客&quot;&gt;&lt;a href=&quot;#使用github-hexo创建一个博客&quot; class=&quot;headerlink&quot; title=&quot;使用github+hexo创建一个博客&quot;&gt;&lt;/a&gt;使用github+hexo创建一个博客&lt;/h1&gt;&lt;p&gt;gi
      
    
    </summary>
    
      <category term="小技巧" scheme="https://dilidonglong.github.io/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
</feed>
