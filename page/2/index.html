<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
    <meta name="keywords" content="network,linux">
  
  
    <meta name="description" content="兰芝生于幽谷，不以无人而不芳">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    望伊如西の博客</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="jumbotron">
  <div class="video">
    
      <div class="video-frame">
        <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
      </div>
    
    <div class="video-media">
      <video playsinline autoplay loop muted data-autoplay poster="/images/ocean/ocean.png" x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">望伊如西の博客</a></h1>
      <p>兰芝生于幽谷，不以无人而不芳</p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="望伊如西の博客"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>

<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>

    
      
        <article id="post-tcpdump技巧" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/04/30/tcpdump技巧/">tcpdump技巧</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/04/30/tcpdump技巧/" class="article-date">
  <time datetime="2019-04-30T15:44:49.000Z" itemprop="datePublished">2019-04-30</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h1 id="tcpdump使用技巧"><a href="#tcpdump使用技巧" class="headerlink" title="tcpdump使用技巧"></a>tcpdump使用技巧</h1><p>1.监视指定网络接口的数据包</p>
<p>   [root@www ~]# tcpdump -i eth1                          </p>
<p>2.也可以指定ip,例如截获所有210.27.48.1 的主机收到的和发出的所有的数据包</p>
<p>   [root@www ~]# tcpdump host 210.27.48.1       </p>
<p>3.截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信</p>
<p>   [root@www ~]# tcpdump host 210.27.48.1 and \ (210.27.48.2 or 210.27.48.3 \ )      </p>
<p>4.获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包</p>
<p>   [root@www ~]# tcpdump ip host 210.27.48.1 and ! 210.27.48.2     </p>
<p>5.截获主机webserver发送的所有数据</p>
<p>   [root@www ~]# tcpdump -i eth0 src host webserver </p>
<p>6.监视所有送到主机webserver的数据包       </p>
<p>   [root@www ~]# tcpdump -i eth0 dst host webserver        </p>
<p>7.获取主机210.27.48.1接收或发出的telnet包</p>
<p>   [root@www ~]# tcpdump tcp port 23 and host 210.27.48.1       </p>
<p>8.打印所有源地址或目标地址是本地主机的IP数据包</p>
<p>   [root@www ~]# tcpdump ip and not net localnet       </p>
<p> 9.打印长度超过576字节</p>
<p>   [root@www ~]# tcpdump ip[2:2] &gt; 576     </p>
<p>10.第一个n表示以IP地址的方式显示主机名，第二个N是以端口数字的形式代替服务名。</p>
<p>   [root@www ~]# tcpdump -nn </p>
<hr>
<p>[root@www ~]# tcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap<br>(1)tcp: ip icmp arp rarp 和 tcp、udp、icmp这些选项等都要放到第一个参数的位置，用来过滤数据报的类型<br>(2)-i eth1 : 只抓经过接口eth1的包<br>(3)-t : 不显示时间戳<br>(4)-s 0 : 抓取数据包时默认抓取长度为68字节。加上-S 0 后可以抓到完整的数据包<br>(5)-c 100 : 只抓取100个数据包<br>(6)dst port ! 22 : 不抓取目标端口是22的数据包<br>(7)src net 192.168.1.0/24 : 数据包的源网络地址为192.168.1.0/24<br>(8)-w ./target.cap : 保存成cap文件，方便用ethereal(即wireshark)分析</p>

      

      

          
        
          
        </div>

    </div>
    <footer class="article-footer">
      <a data-url="https://dilidonglong.github.io/2019/04/30/tcpdump技巧/" data-id="cjwrxy05s0000bkquu28u9eq5" class="article-share-link">分享</a>
      
    </footer>

  

  

  

</article>



      
        <article id="post-wireshark技巧" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/04/30/wireshark技巧/">wireshark技巧</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/04/30/wireshark技巧/" class="article-date">
  <time datetime="2019-04-30T15:40:03.000Z" itemprop="datePublished">2019-04-30</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/小技巧/">小技巧</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h1 id="wireshark技巧"><a href="#wireshark技巧" class="headerlink" title="wireshark技巧"></a>wireshark技巧</h1><blockquote>
<p>资料来源：</p>
<p><a href="https://community.emc.com/go/chinese" target="_blank" rel="noopener">1.EMC中文支持论坛</a></p>
<p><a href="https://www.dell.com/community/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%AE%A8%E8%AE%BA%E5%8C%BA/%E5%A6%82%E6%9E%9C%E7%9C%8B%E4%BA%86%E8%BF%99%E4%B8%AA%E4%BD%A0%E8%BF%98%E6%98%AF%E4%B8%8D%E4%BC%9A%E7%94%A8Wireshark-%E9%82%A3%E5%B0%B1%E6%9D%A5%E6%89%BE%E6%88%91%E5%90%A7-8%E6%9C%886%E6%97%A5%E5%AE%8C%E7%BB%93/td-p/7007033/page/5" target="_blank" rel="noopener">2.如果看了这个你还是不会用Wireshark-那就来找我吧-8月6日完结</a></p>
<p><a href="http://linux.51yip.com/search/tcpdump" target="_blank" rel="noopener">3.Linux命令手册-tcpdump</a></p>
<p><a href="https://chegva.com/3019.html" target="_blank" rel="noopener">4.Linux上使用wireshark(tshark)抓包分析</a></p>
<p><a href="https://chegva.com/2473.html" target="_blank" rel="noopener">5.tcpdump使用技巧</a></p>
</blockquote>
<h2 id="1-抓包前设置过滤条件（捕捉过滤器）"><a href="#1-抓包前设置过滤条件（捕捉过滤器）" class="headerlink" title="1.抓包前设置过滤条件（捕捉过滤器）"></a>1.抓包前设置过滤条件（捕捉过滤器）</h2><p><strong>尽量避免使用抓包过滤。即便多看几个报文，也比漏看一个报文要好。</strong>当你抓取了大量报文的时候，用显示过滤（过滤选项也更多）来重点查看某一数据流。</p>
<h3 id="1-1-抓取指定IP地址的数据流："><a href="#1-1-抓取指定IP地址的数据流：" class="headerlink" title="1.1 抓取指定IP地址的数据流："></a>1.1 抓取指定IP地址的数据流：</h3><ol>
<li>host 10.3.1.1：抓取发到/来自10.3.1.1的数据流</li>
<li>host 2406:da00:ff00::6b16:f02d：抓取发到/来自IPv6地址2406:da00:ff00::6b16:f02d的数据流</li>
<li>not host 10.3.1.1：抓取除了发到/来自10.3.1.1以外的所有数据流</li>
<li>src host 10.3.1.1：抓取来自10.3.1.1的数据流</li>
<li>dst host 10.3.1.1：抓取发到10.3.1.1的数据流</li>
<li>host 10.3.1.1 or 10.3.1.2：抓取发到/来自10.3.1.1，以及与之通讯的所有数据流，与10.3.1.2，以及与之通讯的所有数据流</li>
<li>host <a href="http://www.espn.com：抓取发到/来自所有解析为www.espn.com的IP地址的数据流" target="_blank" rel="noopener">www.espn.com：抓取发到/来自所有解析为www.espn.com的IP地址的数据流</a></li>
</ol>
<h3 id="1-2-抓取指定IP地址范围的数据流"><a href="#1-2-抓取指定IP地址范围的数据流" class="headerlink" title="1.2 抓取指定IP地址范围的数据流:"></a>1.2 抓取指定IP地址范围的数据流:</h3><ol>
<li>net 10.3.0.0/16：抓取网络10.3.0.0上发到/来自所有主机的数据流(16表示长度)</li>
<li>net 10.3.0.0 mask 255.255.0.0：与之前的过滤结果相同</li>
<li>ip6 net 2406:da00:ff00::/64：抓取网络2406:da00:ff00:0000(IPv6)上发到/来自所有主机的数据流</li>
<li>not dst net 10.3.0.0/16：抓取除了发到以10.3开头的IP地址以外的所有数据流</li>
<li>not src net 10.3.0.0/16：抓取除了来自以10.3开头的IP地址以外的所有数据流</li>
<li>ip proto &lt; protocol code &gt;：抓取ip协议字段等于&lt; protocol code &gt;值的报文。如TCP(code 6), UDP(code 17), ICMP(code 1)。</li>
<li>ip[2:2]==&lt; number &gt;：ip报文大小</li>
<li>ip[8]==&lt; number &gt;：TTL(Time to Live)值</li>
<li>ip[9]==&lt; number &gt;：协议值</li>
<li>icmp[icmptype]==&lt; identifier &gt;: 抓取 ICMP代码等于identifier的ICMP报文, 如icmp-echo 以及 icmp-request。</li>
</ol>
<p>方括号中第一个数字表示从<u><strong>协议头</strong></u>开始的偏移量，第二个数字表示需要观察多少位。</p>
<p><img src="/2019/04/30/wireshark技巧/1.png" alt="image004.png"></p>
<h3 id="1-3-抓取发到广播或多播地址的数据流"><a href="#1-3-抓取发到广播或多播地址的数据流" class="headerlink" title="1.3 抓取发到广播或多播地址的数据流:"></a>1.3 抓取发到广播或多播地址的数据流:</h3><p>只需侦听广播或多播数据流，就可以掌握网络上主机的许多信息。</p>
<ol>
<li>ip broadcast：抓取广播报文</li>
<li>ip multicast：抓取多播报文</li>
<li>dst host ff02::1：抓取到IPv6多播地址所有主机的数据流</li>
<li>dst host ff02::2：抓取到IPv6多播地址所有路由器的数据流</li>
</ol>
<h3 id="1-4-抓取基于MAC地址的数据流"><a href="#1-4-抓取基于MAC地址的数据流" class="headerlink" title="1.4 抓取基于MAC地址的数据流:"></a>1.4 抓取基于MAC地址的数据流:</h3><p>当你需要抓取发到/来自某一主机的IPv4或IPv6数据流，可创建基于主机MAC地址的抓包过滤条件。</p>
<p>应用MAC地址时，需确保与目标主机处于同一网段。</p>
<ol>
<li>ether host 00:08:15:00:08:15：抓取发到/来自00:08:15:00:08:15的数据流</li>
<li>ether src 02:0A:42:23:41:AC：抓取来自02:0A:42:23:41:AC的数据流</li>
<li>ether dst 02:0A:42:23:41:AC：抓取发到02:0A:42:23:41:AC的数据流</li>
<li>not ether host 00:08:15:00:08:15：抓取除了发到/来自00:08:15:00:08:15以外的所有数据流</li>
<li>ether broadcast或ether dst ff:ff:ff:ff:ff:ff：抓取广播报文</li>
<li>ether multicast：多播报文</li>
<li>抓取指定以太网类型的报文：ether proto 0800</li>
<li>抓取指定VLAN：vlan &lt; vlan number &gt;</li>
<li>抓取指定几个VLAN：vlan &lt; vlan number &gt; and vlan &lt; vlan number &gt;</li>
</ol>
<h3 id="1-5-抓取基于指定应用的数据流"><a href="#1-5-抓取基于指定应用的数据流" class="headerlink" title="1.5 抓取基于指定应用的数据流:"></a>1.5 抓取基于指定应用的数据流:</h3><p>你可能需要查看基于一个或几个应用的数据流。抓包过滤器语法无法识别应用名，因此需要根据端口号来定义应用。通过目标应用的TCP或UDP端口号，将不相关的报文过滤掉。</p>
<ol>
<li>port 53：抓取发到/来自端口53的UDP/TCP数据流（典型是DNS数据流）</li>
<li>not port 53：抓取除了发到/来自端口53以外的UDP/TCP数据流</li>
<li>port 80：抓取发到/来自端口80的UDP/TCP数据流（典型是HTTP数据流）</li>
<li>udp port 67：抓取发到/来自端口67的UDP数据流（典型是DHCP据流）</li>
<li>tcp port 21：抓取发到/来自端口21的TCP数据流（典型是FTP命令通道）</li>
<li>portrange 1-80：抓取发到/来自端口1-80的所有UDP/TCP数据流</li>
<li>tcp portrange 1-80：抓取发到/来自端口1-80的所有TCP数据流</li>
</ol>
<h3 id="1-6-抓取结合端口的数据流"><a href="#1-6-抓取结合端口的数据流" class="headerlink" title="1.6 抓取结合端口的数据流:"></a>1.6 抓取结合端口的数据流:</h3><p>当你需要抓取多个不连续端口号的数据流，将它们通过逻辑符号连接起来，如下图所示：</p>
<ol>
<li>port 20 or port 21：抓取发到/来自端口20或21的UDP/TCP数据流（典型是FTP数据和命令端口）</li>
<li>host 10.3.1.1 and port 80：抓取发到/来自10.3.1.1端口80的数据流</li>
<li>host 10.3.1.1 and not port 80：抓取发到/来自10.3.1.1除了端口80以外的数据流</li>
<li>udp src port 68 and udp dst port 67：抓取从端口68到端口67的所有UDP数据流（典型是从DHCP客户端到DHCP服务器）</li>
<li>udp src port 67 and udp dst port 68：抓取从端口67到端口68的所有UDP数据流（典型是从DHCP服务器到DHCP客户端）</li>
<li>抓取TCP连接的开始（SYN）和结束（FIN）报文，配置tcp[tcpflags] &amp; (tcp-syn|tcp-fin)!=0</li>
<li>抓取所有RST(Reset)标志位为1的TCP报文，配置tcp[tcpflags] &amp; (tcp-rst)!=0</li>
<li>less &lt; length &gt;：抓取小于等于某一长度的报文，等同于len &lt;=&lt; length &gt;</li>
<li>greater &lt; length &gt;：抓取大于等于某一长度的报文，等同于len &gt;=&lt; length &gt;</li>
</ol>
<p>SYN: 建立连接的信号</p>
<p>FIN: 关闭连接的信号</p>
<p>ACK: 确认接收数据的信号</p>
<p>RST: 立即关闭连接的信号</p>
<p>PSH: 推信号，尽快将数据转由应用处理</p>
<ul>
<li>tcp[13] &amp; 0x00 = 0: No flags set (null scan)</li>
<li>tcp[13] &amp; 0x01 = 1: FIN set and ACK not set</li>
<li>tcp[13] &amp; 0x03 = 3: SYN set and FIN set</li>
<li>tcp[13] &amp; 0x05 = 5: RST set and FIN set</li>
<li>tcp[13] &amp; 0x06 = 6: SYN set and RST set</li>
<li>tcp[13] &amp; 0x08 = 8: PSH set and ACK not set</li>
<li>tcp[13]是从<u><strong>协议头</strong></u>开始的偏移量，0,1,3,5,6,8是标识位。</li>
</ul>
<p><img src="/2019/04/30/wireshark技巧/2.png" alt="image005.png"></p>
<hr>
<h2 id="2-抓包后设置过滤条件（显示过滤器）"><a href="#2-抓包后设置过滤条件（显示过滤器）" class="headerlink" title="2.抓包后设置过滤条件（显示过滤器）"></a>2.抓包后设置过滤条件（显示过滤器）</h2><h3 id="2-1-协议过滤器"><a href="#2-1-协议过滤器" class="headerlink" title="2.1 协议过滤器"></a>2.1 协议过滤器</h3><ol>
<li>arp：显示所有包括ARP请求和回复在内的所有ARP数据流。</li>
<li>ip：显示内含IPv4头在内的（如ICMP目的地址不可达报文，在ICMP报文头之后返回到来方向的IPv4头）IP数据流。</li>
<li>ipv6：显示所有IPv6数据流，包括内含IPv6报文头的IPv4报文，如6to4，Teredo，以及ISATAP数据流。</li>
<li>tcp：显示所有基于TCP的数据流。</li>
</ol>
<h3 id="2-2-应用过滤器"><a href="#2-2-应用过滤器" class="headerlink" title="2.2 应用过滤器"></a>2.2 应用过滤器</h3><ol>
<li>bootp：显示所有DHCP数据流（基于BOOTP）。</li>
<li>dns：显示包括TCP区域传输以及基于标准UDP的DNS请求和回复在内的所有DNS数据流。</li>
<li>tftp：显示所有TFTP（Trivial File Transfer Protocol）数据流。</li>
<li>http：显示所有HTTP命令，回复以及数据传输报文，但不显示TCP握手报文，TCP ACK报文以及TCP结束报文。</li>
<li>icmp：显示所有ICMP报文。</li>
</ol>
<h3 id="2-3-字符过滤器"><a href="#2-3-字符过滤器" class="headerlink" title="2.3 字符过滤器"></a>2.3 字符过滤器</h3><ol>
<li>tcp.analysis.flags：显示所有包含TCP分析标识的所有报文，包括报文丢失，重传，或零窗口标识。</li>
<li>tcp.analysis.zero_window：显示含有表明发送方的接收缓存用完标识的报文。</li>
</ol>
<h3 id="2-4-域过滤器"><a href="#2-4-域过滤器" class="headerlink" title="2.4 域过滤器"></a>2.4 域过滤器</h3><ol>
<li>boot.option.hostname：显示所有包含主机名的DHCP数据流（DHCP基于BOOTP）。</li>
<li>http:host：显示所有包含HTTP主机名字段的所有HTTP报文。此报文是客户端向网络服务器发送请求时发出的。</li>
<li>ftp.request.command：显示所有包含命令的FTP数据流，比如USER，PASS，或RETR命令。</li>
</ol>
<h3 id="2-5-显示过滤器的比较运算符"><a href="#2-5-显示过滤器的比较运算符" class="headerlink" title="2.5 显示过滤器的比较运算符"></a>2.5 显示过滤器的比较运算符</h3><ol>
<li><p>==或eq</p>
<p>例如：ip.src == 10.2.2.2</p>
<p>显示所有源地址为10.2.2.2的IPv4数据流</p>
</li>
<li><p>！=或ne</p>
<p>例如：tcp.srcport != 80</p>
<p>显示源端口除了80以外的所有TCP数据流</p>
</li>
<li><p>gt 或 &gt;</p>
<p>例如：frame.time_relative &gt; 1</p>
<p>显示距前一个报文到达时间相差1秒的报文</p>
</li>
<li><p>&lt;或lt</p>
<p>例如：tcp.window_size &lt; 1460</p>
<p>显示当TCP接收窗口小于1460字节时的报文</p>
</li>
<li><p>ge 或 &gt;=</p>
<p>例如：dns.count.answers &gt;= 10</p>
<p>显示包含10个以上answer的DNS响应报文</p>
</li>
<li><p>&lt;=或le</p>
<p>例如：ip.ttl &lt;= 10</p>
<p>显示IP报文中Time to Live字段小于等于10的报文</p>
</li>
<li><p>contains</p>
<p>例如：http contains “GET”</p>
<p>显示所有HTTP客户端发送给HTTP服务器的GET请求</p>
</li>
</ol>
<p>对于基于TCP应用的过滤条件采用比较运算符。例如，如果想看端口80上面的HTTP数据流，使用HTTP.port==80。</p>
<p>小贴士：</p>
<p>运算符两边不用留空格。ip.src == 10.2.2.2与ip.src==10.2.2.2的效果是相同的。</p>
<h3 id="2-6-举例应用"><a href="#2-6-举例应用" class="headerlink" title="2.6 举例应用"></a>2.6 举例应用</h3><h4 id="2-6-1-按照某一IP地址或主机过滤报文："><a href="#2-6-1-按照某一IP地址或主机过滤报文：" class="headerlink" title="2.6.1 按照某一IP地址或主机过滤报文："></a>2.6.1 按照某一IP地址或主机过滤报文：</h4><ul>
<li><p>例如：ip.addr==10.3.1.1</p>
<p>显示在IP源地址字段或IP目的地址字段包含10.3.1.1的帧。</p>
<hr>
</li>
<li><p>例如：！ip.addr==10.3.1.1</p>
<p>显示除了在IP源地址字段或IP目的地址字段包含10.3.1.1以外的帧。</p>
<hr>
</li>
<li><p>例如：ipv6.addr==2406:da00:ff00::6b16:f02d</p>
<p>显示以2406:da00:ff00::6b16:f02d为源地址或目的地址的帧。</p>
<hr>
</li>
<li><p>例如：ip.src==10.3.1.1</p>
<p>显示所有来自10.3.1.1的数据流。</p>
<hr>
</li>
<li><p>例如：ip.dst==10.3.1.1</p>
<p>显示所有发往10.3.1.1的数据流</p>
<hr>
</li>
<li><p>例如：ip.host==<a href="http://www.wireshark.org" target="_blank" rel="noopener">www.wireshark.org</a></p>
<p>显示所有解析为<a href="http://www.wireshark.org的IP" target="_blank" rel="noopener">www.wireshark.org的IP</a></p>
<hr>
</li>
</ul>
<h4 id="2-6-2-按照某一IP地址范围过滤报文："><a href="#2-6-2-按照某一IP地址范围过滤报文：" class="headerlink" title="2.6.2 按照某一IP地址范围过滤报文："></a>2.6.2 按照某一IP地址范围过滤报文：</h4><p>可以使用&gt;或&lt;比较运算符或逻辑运算符&amp;&amp;查找某一地址范围内的报文。</p>
<ul>
<li><p>例如：ip.addr&gt;10.3.0.1&amp;&amp;ip.addr&lt;10.3.0.5</p>
<p>显示来自或发往10.3.0.2，10.3.0.3，10.3.0.4的数据流。</p>
<hr>
</li>
<li><p>例如：(ip.addr&gt;=10.3.0.1&amp;&amp;ip.addr&lt;=10.3.0.6)&amp;&amp;!ip.addr==10.3.0.3</p>
<p>显示来自或发往10.3.0.1，10.3.0.2，10.3.0.4，10.3.0.5，10.3.0.6的数据流，10.3.0.3排除在外。</p>
<hr>
</li>
<li><p>例如：ipv6.addr&gt;=fe80::&amp;&amp;ipv6.addr&lt;fec0::</p>
<p>显示IPv6地址从0xfe80到0xfec0开头的数据流。</p>
<hr>
</li>
</ul>
<h4 id="2-6-3-按照某一IP子网过滤报文："><a href="#2-6-3-按照某一IP子网过滤报文：" class="headerlink" title="2.6.3 按照某一IP子网过滤报文："></a>2.6.3 按照某一IP子网过滤报文：</h4><p>可以通过ip.addr字段名定义一个子网。这种格式使用IP地址后跟斜杠以及一个后缀，表明IP地址中定义的网络部分的比特数。</p>
<ul>
<li><p>例如：ip.addr==10.3.0.0/16</p>
<p>显示在IP源地址或目的地址字段以10.3开头的数据流。</p>
<hr>
</li>
<li><p>例如：ip.addr == 10.3.0.0/16 &amp;&amp; ！ip.addr==10.3.1.1</p>
<p>显示除了10.3.1.1以外，在IP源地址或目的地址字段以10.3开头的数据流。</p>
<hr>
</li>
<li><p>例如：!ip.addr == 10.3.0.0/16 &amp;&amp; !ip.addr==10.2.0.0/16</p>
<p>显示所有数据流，除了在IP源地址或目的地址字段以10.3和10.2开头的数据流</p>
<hr>
</li>
</ul>
<blockquote>
<p>注意：</p>
<p>错误的用法导致不work：</p>
<hr>
<p>错误：ip.addr != 10.2.2.2</p>
<p>显示在IP源地址或IP目的地址不包含10.2.2.2的报文。只要在源或目的IP地址不为10.2.2.2，报文就会被显示出来。这时隐含的或会导致实际上并未过滤任何报文。</p>
<p>正确：！ip.addr == 10.2.2.2</p>
<p>显示IP源地址和IP目的地址都不包含10.2.2.2的报文。</p>
<hr>
<p>错误：!tcp.flags.syn==1</p>
<p>显示所有不含TCP SYN bit设置为1的报文。其他协议报文，必须UDP和ARP报文也符合这一过滤条件，因为它们的TCP SYN bit没有设置为1。</p>
<p>正确：tcp.flags.syn！=1</p>
<p>只显示包含SYN设置为0的TCP报文。</p>
<hr>
</blockquote>

      

      

          
        
          
        </div>

    </div>
    <footer class="article-footer">
      <a data-url="https://dilidonglong.github.io/2019/04/30/wireshark技巧/" data-id="cjwrxy07o000zbkque3r6ndva" class="article-share-link">分享</a>
      
    </footer>

  

  

  

</article>



      
        <article id="post-文件系统的简单操作" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/04/30/文件系统的简单操作/">文件系统的简单操作</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/04/30/文件系统的简单操作/" class="article-date">
  <time datetime="2019-04-30T15:34:18.000Z" itemprop="datePublished">2019-04-30</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h1 id="文件系统的简单操作"><a href="#文件系统的简单操作" class="headerlink" title="文件系统的简单操作"></a>文件系统的简单操作</h1><h2 id="1-df和du命令"><a href="#1-df和du命令" class="headerlink" title="1.df和du命令"></a>1.df和du命令</h2><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>列出文件系统的整体磁盘使用量，df读取的数据几乎针对一整个文件系统，因为读取范围是<strong>超级区块</strong>内的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@vultr ~]<span class="comment"># df</span></span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">devtmpfs          214728       0    214728   0% /dev</span><br><span class="line">tmpfs             246392       0    246392   0% /dev/shm</span><br><span class="line">/dev/vda1       10291200 2231176   7519412  23% /</span><br><span class="line"><span class="comment"># Filesystem表示文件系统在哪个磁盘分区</span></span><br><span class="line"><span class="comment"># 1K-blocks表示单位为1k，可以利用-h来变成人们易于理解的单位格式</span></span><br><span class="line"><span class="comment"># Mounted on表示挂载点</span></span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">[root@vultr ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs        210M     0  210M   0% /dev</span><br><span class="line">tmpfs           241M     0  241M   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1       9.9G  2.2G  7.2G  23% /</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">[root@vultr ~]<span class="comment"># df -Th</span></span><br><span class="line">Filesystem     Type      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs       devtmpfs  210M     0  210M   0% /dev</span><br><span class="line">tmpfs          tmpfs     241M     0  241M   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1      ext4      9.9G  2.2G  7.2G  23% /</span><br><span class="line"><span class="comment"># Type表示文件系统类型</span></span><br></pre></td></tr></table></figure>
<h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p>du不同于df，du会在整个文件系统内去<strong>查找所有的文件数据</strong></p>
<h2 id="2-硬件链接和软链接（符号链接）"><a href="#2-硬件链接和软链接（符号链接）" class="headerlink" title="2.硬件链接和软链接（符号链接）"></a>2.硬件链接和软链接（符号链接）</h2><h3 id="2-1硬件链接"><a href="#2-1硬件链接" class="headerlink" title="2.1硬件链接"></a>2.1硬件链接</h3><p>目录的数据区块下新增一条文件名链接到某个inode号码的<strong>关联记录</strong>。即多个文件名对应到同一个inode号码。</p>
<p>硬链接的限制：1.不能跨文件系统。2.不能连接目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@vultr tmp]<span class="comment"># ll -i</span></span><br><span class="line">total 4</span><br><span class="line"> 11618 -rw-r--r-- 1 root root    0 Apr 18 06:16 <span class="built_in">test</span></span><br><span class="line">[root@vultr tmp]<span class="comment"># </span></span><br><span class="line">[root@vultr tmp]<span class="comment"># ln test zhang</span></span><br><span class="line">[root@vultr tmp]<span class="comment"># ll -i</span></span><br><span class="line">total 4</span><br><span class="line"> 11618 -rw-r--r-- 2 root root    0 Apr 18 06:16 <span class="built_in">test</span></span><br><span class="line"> 11618 -rw-r--r-- 2 root root    0 Apr 18 06:16 zhang</span><br></pre></td></tr></table></figure>
<h3 id="2-2符号链接"><a href="#2-2符号链接" class="headerlink" title="2.2符号链接"></a>2.2符号链接</h3><p>符号链接就是建立一个独立的<strong>文件</strong>，而这个文件会让数据的读取指向它连接的那个文件的文件名</p>
<p>当源文件被删除后，符号链接的文件就会打不开。类似于是Windows下的快捷方式</p>
<p>需要注意的是，通过符号链接进入到了某个目录或是打开了某个文件。操作的对象实际上还是原始文件。所以你在符号链接里面打开了东西，进行了操作，那原始文件也会发生改变。如果你在符号链接里面把内容删除了，相当于原始文件的实际内容也删除了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@vultr tmp]<span class="comment"># ln -s test zhangshuaiyang            加上-s就是符号链接，不加是硬链接</span></span><br><span class="line">[root@vultr tmp]<span class="comment"># ll -i</span></span><br><span class="line">total 4</span><br><span class="line"> 11618 -rw-r--r-- 2 root root    0 Apr 18 06:16 <span class="built_in">test</span></span><br><span class="line"> 11618 -rw-r--r-- 2 root root    0 Apr 18 06:16 zhang</span><br><span class="line"> 23193 lrwxrwxrwx 1 root root    4 Apr 18 06:43 zhangshuaiyang -&gt; <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<h2 id="3-磁盘分区、格式化、检验及挂载"><a href="#3-磁盘分区、格式化、检验及挂载" class="headerlink" title="3.磁盘分区、格式化、检验及挂载"></a>3.磁盘分区、格式化、检验及挂载</h2><p>如果想在系统里面新增一块硬盘，操作过程如下：</p>
<ol>
<li>对磁盘进行划分，进行磁盘分区</li>
<li>对分区进行格式化，以建立文件系统</li>
<li>对文件系统进行检验（可选）</li>
<li>在linux系统上，建立一个挂载点（目录），把该文件系统挂载上来</li>
</ol>
<h3 id="3-1查看磁盘分区状态"><a href="#3-1查看磁盘分区状态" class="headerlink" title="3.1查看磁盘分区状态"></a>3.1查看磁盘分区状态</h3><p><strong>lsblk</strong>（list block device）显示出所有存储设备</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@vultr tmp]<span class="comment"># lsblk</span></span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0     11:0    1 1024M  0 rom  </span><br><span class="line">vda    253:0    0   10G  0 disk </span><br><span class="line">└─vda1 253:1    0   10G  0 part /</span><br><span class="line"><span class="comment">#name表示设备文件名，会省略/dev等前面的目录；disk表示一整块磁盘；part表示分区</span></span><br><span class="line"><span class="comment">#在vda这个磁盘下，有一个分区vda1</span></span><br><span class="line">----------------------------------------------------------</span><br><span class="line">[root@vultr tmp]<span class="comment"># lsblk -ipf                 通过-f选项可以列出UUID</span></span><br><span class="line">NAME        FSTYPE LABEL UUID                                 MOUNTPOINT</span><br><span class="line">/dev/sr0                                                      </span><br><span class="line">/dev/vda                                                      </span><br><span class="line">`-/dev/vda1 ext4         19c82273-828c-4d85-bc4e-6fc269acc524 /</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">[root@vultr tmp]<span class="comment"># blkid                       通过blkid也可以显示出UUID</span></span><br><span class="line">/dev/vda1: UUID=<span class="string">"19c82273-828c-4d85-bc4e-6fc269acc524"</span> TYPE=<span class="string">"ext4"</span></span><br></pre></td></tr></table></figure>
<p><strong>parted</strong>列出磁盘的分区表类型及分区信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@vultr tmp]<span class="comment"># parted /dev/vda print</span></span><br><span class="line">Model: Virtio Block Device (virtblk)</span><br><span class="line">Disk /dev/vda: 10.7GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: msdos                     <span class="comment">#分区表格式，比如MBR/GPT，这里显示的是msdos</span></span><br><span class="line">Disk Flags: </span><br><span class="line">										   <span class="comment">#下面内容是分区数据</span></span><br><span class="line">Number  Start   End     Size    Type     File system  Flags</span><br><span class="line"> 1      1049kB  10.7GB  10.7GB  primary  ext4         boot</span><br></pre></td></tr></table></figure>
<h3 id="3-2磁盘分区"><a href="#3-2磁盘分区" class="headerlink" title="3.2磁盘分区"></a>3.2磁盘分区</h3><p>MBR分区表使用fdisk工具进行，GPT分区表使用gdisk工具进行。</p>
<h3 id="3-3磁盘格式化"><a href="#3-3磁盘格式化" class="headerlink" title="3.3磁盘格式化"></a>3.3磁盘格式化</h3><p>所谓格式化，其实是指在分区上创建文件系统。使用的命令是mkfs（make filesystem）</p>
<p>如果我们要创建的文件系统是xfs。那么命令的写法就是mkfs.xfs。例如<code>mkfs.xfs /dev/vda4</code>，表示在/dev/vda4这个分区上建立一个xfs文件系统。</p>
<p>如果是创建ext4文件系统。则命令写法是mkfs.ext4。只是xfs的文件系统建立起来速度更快。</p>
<p>想知道能创建哪些文件系统。只要再命令行中输入<code>mkfs[tab][tab]</code>，就能看到了。</p>
<h3 id="3-4文件系统的挂载"><a href="#3-4文件系统的挂载" class="headerlink" title="3.4文件系统的挂载"></a>3.4文件系统的挂载</h3><p>注意点：</p>
<ol>
<li>单一文件系统不要被重复挂载到不同的挂载点中</li>
<li>单一目录不要重复挂载多个文件系统</li>
<li>作为挂载点的目录，最好是空目录</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@vultr tmp]<span class="comment"># blkid                       </span></span><br><span class="line">/dev/vda1: UUID=<span class="string">"19c82273-828c-4d85-bc4e-6fc269acc524"</span> TYPE=<span class="string">"ext4"</span> </span><br><span class="line"></span><br><span class="line">[root@vultr tmp]<span class="comment"># mount UUID="19c82273-828c-4d85-bc4e-6fc269acc524" /data/ext4</span></span><br><span class="line">其中UUID表示文件系统的ID。/data/ext4表示挂载点。也就是说把这个文件系统挂载在/data/ext4目录下。</span><br></pre></td></tr></table></figure>

      

      

          
        
          
        </div>

    </div>
    <footer class="article-footer">
      <a data-url="https://dilidonglong.github.io/2019/04/30/文件系统的简单操作/" data-id="cjwrxy06g0007bkqu9vrcjfwr" class="article-share-link">分享</a>
      
    </footer>

  

  

  

</article>



      
        <article id="post-文件系统" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/04/30/文件系统/">文件系统</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/04/30/文件系统/" class="article-date">
  <time datetime="2019-04-30T15:33:00.000Z" itemprop="datePublished">2019-04-30</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p><strong>柱面</strong>通常是<strong>分区</strong>及<strong>文件系统</strong>的最小单位。当然如果使用GPT格式的分区表，最小单位可以为<strong>扇区</strong></p>
<p>磁盘分区完后，要进行<strong>格式化</strong>，使之成为操作系统能用的<strong>文件系统</strong></p>
<p>文件（或目录）包含<strong>属性</strong>（比如文件权限，文件属性）及<strong>内容</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">权限与属性</th>
<th style="text-align:center">实际数据</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">inode表</td>
<td style="text-align:center">数据区块</td>
</tr>
</tbody>
</table>
<p>区块有放置<strong>inode表</strong>的区块，有放置<strong>数据</strong>的数据区块，以及记录<strong>整个文件系统整体信息</strong>的超级区块</p>
<blockquote>
<p>超级区块：记录inode和数据区块总量、使用量、剩余量及文件系统格式等</p>
<p>inode：记录文件属性，一个文件占一个inode，同时记录文件对应数据所放置的区块号码</p>
<p>数据区块：记录实际内容，当一个区块占不下的时候，就会占用多个数据区块</p>
</blockquote>
<p><strong>索引式文件系统</strong>，包含了inode。通过inode，我们可以数据存放在哪些数据区块里面，所以可以一次性全部提取出来。该方式性能比较好，比如linux的ext2文件系统</p>
<p>再比如u盘一般使用FAT文件系统，这种就不是索引式文件系统。它没有inode，所以无法把数据一次性全提取出来。每个区块号码都记录在前一个区块里面，所以提取的时候得一个连着一个提取。</p>
<p><strong>碎片整理</strong>，在非索引式文件系统里面，由于有时候数据写入的区块太过于分散，所以读取的时候性能会很差，通过磁盘碎片整理，可以把同一个文件的区块集合在一起，这样读取起来就比较容易。</p>
<h2 id="1-ext2文件系统"><a href="#1-ext2文件系统" class="headerlink" title="1.ext2文件系统"></a>1.ext2文件系统</h2><p>在分区上进行格式化的时候，就已经规划好了<strong>inode</strong>和<strong>数据区块</strong></p>
<p>把放置inode的区块和数据区块全部都放一起，会导致很难管理</p>
<p>所以在ext2的文件系统上，会弄出多个<strong>区块群组</strong>，每个区块群组都有自己的<strong>inode</strong>，<strong>数据区块</strong>和<strong>超级区块</strong></p>
<p>在<strong>文件系统</strong>最前面有个启动扇区，里面可以存放<strong>启动引导程序</strong>。（注：或是想到之前的磁盘分区，分区的第一个扇区用来放MBR，MBR中的446字节来存放启动引导程序）</p>
<p>这种设计可以把引导启动程序放在<strong>不同文件系统</strong>的最前端，而不必把程序全都放在整个磁盘唯一的MBR下。</p>
<h3 id="1-1数据区块"><a href="#1-1数据区块" class="headerlink" title="1.1数据区块"></a>1.1数据区块</h3><p>数据区块用来放置文件数据。ext2文件系统支持的区块大小有1k，2k及4k共3种。</p>
<p>每个区块都有编号，方便inode表记录。</p>
<p>数据放在数据区块里面，如果数据的大小要小于区块的容量的话，就会造成浪费。</p>
<h3 id="1-2inode表"><a href="#1-2inode表" class="headerlink" title="1.2inode表"></a>1.2inode表</h3><p>inode表记录如下内容</p>
<blockquote>
<ul>
<li><strong>该文件的读写属性（读、写、执行）</strong></li>
<li><strong>文件所有者及用户组</strong></li>
<li>文件大小</li>
<li>文件建立或状态改变时间</li>
<li>最近一次读取时间</li>
<li>最近修改时间</li>
<li>定义文件特征标识</li>
<li><strong>文件真正内容指向</strong></li>
</ul>
</blockquote>
<p>inode表的数量和大小在格式化的时候就确定好了</p>
<blockquote>
<ul>
<li>每个inode表大小为128B（其中4B来记录一个数据区块的位置编号，一共能记录12个）</li>
<li>每个文件仅占用一个inode表</li>
<li>文件系统能建立的文件数量和inode数量有关</li>
<li>系统读取文件先找到inode表，分析文件记录用户及权限是否符合，如果符合最后才去找数据区块读取</li>
</ul>
</blockquote>
<h3 id="1-3超级区块"><a href="#1-3超级区块" class="headerlink" title="1.3超级区块"></a>1.3超级区块</h3><p>没有超级区块，就没有文件系统，它记录整个文件系统相关信息。</p>
<blockquote>
<ul>
<li>数据区块与inode的总量</li>
<li>未使用与已经使用的inode与数据区块的数量</li>
<li>数据区块与inode的大小</li>
<li>文件系统的挂载时间、最近一次写入数据时间等文件系统相关信息</li>
<li>一个有效位数值，文件系统被挂载，则有效位为0，未被挂载则为1</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示目前系统被格式化的设备</span></span><br><span class="line">[root@vultr ~]<span class="comment"># blkid</span></span><br><span class="line">/dev/vda1: UUID=<span class="string">"19c82273-828c-4d85-bc4e-6fc269acc524"</span> TYPE=<span class="string">"ext4"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">[root@vultr ~]<span class="comment"># dumpe2fs /dev/vda1</span></span><br><span class="line">dumpe2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">Filesystem volume name:   &lt;none&gt;</span><br><span class="line">Last mounted on:          /</span><br><span class="line">Filesystem UUID:          19c82273-828c-4d85-bc4e-6fc269acc524</span><br><span class="line">Filesystem magic number:  0xEF53</span><br><span class="line">Filesystem revision <span class="comment">#:    1 (dynamic)</span></span><br><span class="line">Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent 64bit flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize</span><br><span class="line">Filesystem flags:         signed_directory_hash </span><br><span class="line">Default mount options:    user_xattr acl</span><br><span class="line">Filesystem state:         clean                    <span class="comment">#文件系统状态，clean表示没问题</span></span><br><span class="line">Errors behavior:          Continue</span><br><span class="line">Filesystem OS <span class="built_in">type</span>:       Linux</span><br><span class="line">Inode count:              640000                   <span class="comment">#inode总数</span></span><br><span class="line">Block count:              2621179                  <span class="comment">#区块总数</span></span><br><span class="line">Reserved block count:     131057                   <span class="comment">#保留的区块总数</span></span><br><span class="line">Free blocks:              2026205                  <span class="comment">#还有多少可用区块</span></span><br><span class="line">Free inodes:              599345                   <span class="comment">#还有多少可用inode</span></span><br><span class="line">First block:              0</span><br><span class="line">Block size:               4096                     <span class="comment">#单个区块大小</span></span><br><span class="line">Fragment size:            4096</span><br><span class="line">Group descriptor size:    64</span><br><span class="line">Reserved GDT blocks:      248</span><br><span class="line">Blocks per group:         32768</span><br><span class="line">Fragments per group:      32768</span><br><span class="line">Inodes per group:         8000</span><br><span class="line">Inode blocks per group:   500</span><br><span class="line">Flex block group size:    16</span><br><span class="line">Filesystem created:       Wed Dec  5 17:22:49 2018</span><br><span class="line">Last mount time:          Wed Apr 10 10:10:48 2019</span><br><span class="line">Last write time:          Wed Apr 10 10:10:46 2019</span><br><span class="line">Mount count:              4</span><br><span class="line">Maximum mount count:      -1</span><br><span class="line">Last checked:             Sat Mar  9 02:38:28 2019</span><br><span class="line">Check interval:           0 (&lt;none&gt;)</span><br><span class="line">Lifetime writes:          3452 MB</span><br><span class="line">Reserved blocks uid:      0 (user root)</span><br><span class="line">Reserved blocks gid:      0 (group root)</span><br><span class="line">First inode:              11</span><br><span class="line">Inode size:	          256                           <span class="comment">#inode表大小</span></span><br><span class="line">Required extra isize:     28</span><br><span class="line">Desired extra isize:      28</span><br><span class="line">Journal inode:            8</span><br><span class="line">Default directory <span class="built_in">hash</span>:   half_md4</span><br><span class="line">Directory Hash Seed:      6cbf0c8a-63c4-43df-aaba-cd82ae9cb153</span><br><span class="line">Journal backup:           inode blocks</span><br><span class="line">Journal features:         journal_incompat_revoke journal_64bit</span><br><span class="line">Journal size:             32M</span><br><span class="line">Journal length:           8192</span><br><span class="line">Journal sequence:         0x0004f118</span><br><span class="line">Journal start:            7195</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Group 0: (Blocks 0-32767) [ITABLE_ZEROED]                <span class="comment">#区块组0所占区块号码为0-32767</span></span><br><span class="line">  Checksum 0x6f25, unused inodes 0</span><br><span class="line">  Primary superblock at 0, Group descriptors at 1-2      <span class="comment">#文件系统描述说明在1-2号区块内</span></span><br><span class="line">  Reserved GDT blocks at 3-250</span><br><span class="line">  Block bitmap at 251 (+251), Inode bitmap at 267 (+267) </span><br><span class="line">                                                    <span class="comment">#区块对照表和inode对照表在251和267区块内</span></span><br><span class="line">  Inode table at 283-782 (+283)                     </span><br><span class="line">  <span class="comment">#一个inode表占256B，总共有782-283+1=500个区块，一个区块大小占4KB。所以inode的总数是500*4kB/256B</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">#以下几行记录，记录了可用的区块数，及可用的inode表述。可知，inode表为0了。</span></span><br><span class="line">  19990 free blocks, 0 free inodes, 1728 directories</span><br><span class="line">  Free blocks: 11866, 11890-11922, 11928-11935, 11943-11951, 12249, 12313, 12350, 12832-32767</span><br><span class="line">  Free inodes: </span><br><span class="line">……后续省略……</span><br></pre></td></tr></table></figure>
<h2 id="2-文件系统与目录树的关系"><a href="#2-文件系统与目录树的关系" class="headerlink" title="2.文件系统与目录树的关系"></a>2.文件系统与目录树的关系</h2><h3 id="2-1目录"><a href="#2-1目录" class="headerlink" title="2.1目录"></a>2.1目录</h3><p>在文件系统上创建一个目录时，文件系统会分配<strong>一个inode</strong>与<strong>至少一块区块</strong>（里面记录了子目录及文件的inode表位置编号）给目录</p>
<h3 id="2-2文件"><a href="#2-2文件" class="headerlink" title="2.2文件"></a>2.2文件</h3><p>在文件系统上创建一个文件时，文件系统会分配<strong>一个inode</strong>及所需个数的<strong>数据区块</strong>。</p>
<h3 id="2-3目录树的读取"><a href="#2-3目录树的读取" class="headerlink" title="2.3目录树的读取"></a>2.3目录树的读取</h3><p>文件存放在目录下，所以我们得要先知道该目录所对应的区块。区块里面记录了子目录及文件的inode表号。找到我想要的文件所对应的inode表号，再去找该文件的inode。找到之后就知道该文件放置在哪个区块了。</p>
<h2 id="3-挂载"><a href="#3-挂载" class="headerlink" title="3.挂载"></a>3.挂载</h2><p>文件系统和目录树结合的操作称为挂载</p>
<p>挂载点一定是目录，该目录为进入文件系统的入口</p>
<p>文件系统要挂载在目录树的某个目录后，我们才能使用该文件系统</p>
<h2 id="4-XFS文件系统"><a href="#4-XFS文件系统" class="headerlink" title="4.XFS文件系统"></a>4.XFS文件系统</h2><p>ext文件系统的支持度虽然广，但是格式化所需要时间长。因为是预先就规划好了inode和区块的位置，所以后续可以直接使用，也就是说并没有使用动态配置的做法</p>
<p>现在的磁盘越来越大，对于虚拟化磁盘那就更大了。对于巨型文件要考虑性能问题，不然虚拟磁盘的处理效率就会差。</p>
<p>xfs是一个日志式文件系统，用于高容量磁盘及高性能文件。同时还几乎有ext4文件系统有的功能。此外，inode与区块都是需要时才动态配置产生，不会预分配，所以格式化操作会很快。</p>
<h3 id="4-1数据区"><a href="#4-1数据区" class="headerlink" title="4.1数据区"></a>4.1数据区</h3><p>包含inode、数据区块、超级区块等数据，类似于之前ext里面的区块群组</p>
<h3 id="4-2文件系统活动登陆区"><a href="#4-2文件系统活动登陆区" class="headerlink" title="4.2文件系统活动登陆区"></a>4.2文件系统活动登陆区</h3><p>用来记录文件系统的变化，有点像日志区</p>
<h3 id="4-3实时运行区"><a href="#4-3实时运行区" class="headerlink" title="4.3实时运行区"></a>4.3实时运行区</h3><p>当有文件要被建立时，xfs会在这个区段里找一个到数个的扩展区块，将文件放置在这个区块内，等分配完毕再写入到数据区的inode与区块中。</p>

      

      

          
        
          
        </div>

    </div>
    <footer class="article-footer">
      <a data-url="https://dilidonglong.github.io/2019/04/30/文件系统/" data-id="cjwrxy07q0010bkqu55gfy379" class="article-share-link">分享</a>
      
    </footer>

  

  

  

</article>



      
        <article id="post-磁盘分区" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/04/30/磁盘分区/">磁盘分区</a>
    </h2>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2019/04/30/磁盘分区/" class="article-date">
  <time datetime="2019-04-30T15:32:07.000Z" itemprop="datePublished">2019-04-30</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h1 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h1><h2 id="1-磁盘分区"><a href="#1-磁盘分区" class="headerlink" title="1.磁盘分区"></a>1.磁盘分区</h2><p><strong>磁盘</strong>包含：碟片（细分为<strong>扇区</strong>和<strong>磁道</strong>）、机械手臂、磁头、主轴马达</p>
<p><strong>扇区</strong>大小分为<strong>512B</strong>和<strong>4KB</strong></p>
<h3 id="1-1第一个扇区（MBR）"><a href="#1-1第一个扇区（MBR）" class="headerlink" title="1.1第一个扇区（MBR）"></a>1.1第一个扇区（MBR）</h3><p><strong>磁盘第一个扇区</strong>存放<strong>启动引导程序</strong>和<strong>磁盘分区表</strong>（格式分为<strong>MBR</strong>[Windows支持]和<strong>GPT</strong>）</p>
<table>
<thead>
<tr>
<th style="text-align:center">MBR（master boot record）</th>
<th style="text-align:center">启动引导程序</th>
<th style="text-align:center">磁盘分区表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">主引导记录容量（512B）</td>
<td style="text-align:center">446B</td>
<td style="text-align:center">64B</td>
</tr>
</tbody>
</table>
<p>MBR分区表的限制：</p>
<blockquote>
<ol>
<li>分区最多到2TB</li>
<li>MBR仅占一个扇区，被破坏后，很难恢复甚至无法恢复</li>
<li>MBR内的启动引导程序只有446B，无法存储较多的程序代码</li>
</ol>
</blockquote>
<h4 id="1-1-1MBR磁盘分区表"><a href="#1-1-1MBR磁盘分区表" class="headerlink" title="1.1.1MBR磁盘分区表"></a>1.1.1MBR<strong>磁盘分区表</strong></h4><blockquote>
<ol>
<li>分区表占64B，给磁盘划分分区，其实就是对这个分区表做设置</li>
<li>分区表默认最多把一个磁盘分为4个分区</li>
<li>分区分为<strong>主要分区</strong>和<strong>扩展分区</strong></li>
<li>要写入数据到磁盘时，会参考这个分区表</li>
</ol>
</blockquote>
<h4 id="1-1-2MBR扩展分区"><a href="#1-1-2MBR扩展分区" class="headerlink" title="1.1.2MBR扩展分区"></a>1.1.2MBR扩展分区</h4><p>由于磁盘分区表的限制，最多给磁盘划分出4个分区。那么我们可以利用额外的扇区来记录更多的分区信息。</p>
<p>在<strong>扩展分区</strong>的某个地方来记录在扩展分区里面的其他<strong>逻辑分区</strong>信息</p>
<blockquote>
<ol>
<li>扩展分区最多一个</li>
<li>逻辑分区是在扩展分区里面划分出来的</li>
<li>能格式化的是主要分区和逻辑分区，扩展分区不能被格式化</li>
<li>逻辑分区能划分多少个，依据不同操作系统来定</li>
</ol>
</blockquote>
<hr>
<h3 id="1-2GPT磁盘分区表"><a href="#1-2GPT磁盘分区表" class="headerlink" title="1.2GPT磁盘分区表"></a>1.2GPT磁盘分区表</h3><p>现在的磁盘越来越大，如果使用磁盘阵列等技术，那么在Linux平台下看到的磁盘大小可能就有几十个TB。使用MBR格式，要划分分区时，就要2TB/2TB地划分下去。这就可能划分出好几十个分区，为了解决这个问题，就有了GPT这种磁盘分区的格式。</p>
<p>以前扇区大小为512B，现在已经有了4KB的扇区。为兼容所有磁盘，会使用到<strong>逻辑区块地址LBA</strong>（logical block address），LBA默认是512B。在GPT这种格式下，将磁盘的所有区块使用LBA来规划。<code>可以理解为，如果一个扇区的容量是512B，然后LBA默认是512B的话，那么一个扇区就是一个区块。如果一个扇区容量是4KB=8*512B，那么一个区块地址就是1/8扇区</code></p>
<p><strong>第一个LBA</strong>称为<strong>LBA0</strong></p>
<p><strong>MBR使用第一个扇区来记录，而GPT使用了前34个LBA区块来记录。</strong>由于MBR只有一个区块，破坏就难以恢复。不同于MBR，<strong>GPT中会用磁盘的最后34个LBA做备份</strong>。</p>
<h4 id="1-2-1LBA0（MBR兼容区块）"><a href="#1-2-1LBA0（MBR兼容区块）" class="headerlink" title="1.2.1LBA0（MBR兼容区块）"></a>1.2.1LBA0（MBR兼容区块）</h4><table>
<thead>
<tr>
<th style="text-align:center">LBA0</th>
<th style="text-align:center">引导启动程序</th>
<th style="text-align:center">特殊标志符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">逻辑区块地址0</td>
<td style="text-align:center">446B</td>
<td style="text-align:center">64B，表示磁盘使用GPT格式</td>
</tr>
</tbody>
</table>
<h4 id="1-2-2LBA1（GPT表头记录）"><a href="#1-2-2LBA1（GPT表头记录）" class="headerlink" title="1.2.2LBA1（GPT表头记录）"></a>1.2.2LBA1（GPT表头记录）</h4><p>记录磁盘分区表本身的位置和大小，同时记录了备份的GPT分区位置。</p>
<h4 id="1-2-3LBA2-33（实际记录分区信息处）"><a href="#1-2-3LBA2-33（实际记录分区信息处）" class="headerlink" title="1.2.3LBA2-33（实际记录分区信息处）"></a>1.2.3LBA2-33（实际记录分区信息处）</h4><p><strong>从LBA2区块开始，每个LBA可以记录4组分区记录</strong>。所以一个磁盘在默认情况下，可以划分4*32=128个分区。</p>
<p>在MBR中，分区表的大小是64B，而在GPT中是512B。</p>
<p>一个区块记录4组分区，所以在GPT的分区表中，一组分区记录可以占512/4=128B的空间大小。</p>
<p>在这128B的空间中使用64bit来记录开始和结束的扇区号码</p>
<p>每个分区的最大容量限制就是：$2^{64}*512B=8ZB$</p>
<h2 id="2-启动程序"><a href="#2-启动程序" class="headerlink" title="2.启动程序"></a>2.启动程序</h2><p>CMOS是一个嵌入在主板的存储器，存储着各项硬件参数</p>
<p>BIOS是一个写入到主板的固件（<strong>固件是</strong>写入到硬件上的一个<strong>软件程序</strong>）</p>
<blockquote>
<ol>
<li>计算机系统在启动时，主动执行的第一个程序就是BIOS</li>
<li>BIOS执行后，会分析计算机里面的存储设备。比如发现了硬盘，BIOS就去找那个能启动的硬盘</li>
<li>找到该硬盘，就读取第一个扇区的MBR位置，找到那个446B的启动引导程序</li>
</ol>
<p>以上BIOS的任务完成，接下来就是启动引导程序干活了</p>
<ol start="4">
<li>启动引导程序的目的是加载内核文件</li>
</ol>
<p>加载完后，启动引导程序的活也干完了</p>
<ol start="5">
<li>之后就是内核文件开始工作，再之后就是把任务都交给我们熟悉的操作系统完成</li>
</ol>
</blockquote>

      

      

          
        
          
        </div>

    </div>
    <footer class="article-footer">
      <a data-url="https://dilidonglong.github.io/2019/04/30/磁盘分区/" data-id="cjwrxy06a0005bkqu3nlhry50" class="article-share-link">分享</a>
      
    </footer>

  

  

  

</article>



      
  </article>
  
  
    <nav class="page-nav">
      
      <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
    </nav>
  
</section>
</div>

  <footer class="footer">
  
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2019 望伊如西の博客</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>

<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="望伊如西の博客"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">主页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/categories">分类</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">相册</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">归档</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>

<nav class="navbar navbar-bottom">
  <ul class="nav">
      <li class="nav-item">
          <div class="totop" id="totop">
    <i class="fe fe-rocket"></i>
</div>
      </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>

<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/search.js"></script>


<script src="/js/ocean.js"></script>

</body>
</html>