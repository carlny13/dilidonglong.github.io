<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  
    <meta name="keywords" content="network,linux">
  
  
    <meta name="description" content="精卫衔微木，将以填沧海">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    Linux防火墙探索实验 |
    
    望伊如西の博客</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  

<article id="post-Linux防火墙探索实验" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Linux防火墙探索实验
    </h1>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/10/31/Linux防火墙探索实验/" class="article-date">
  <time datetime="2019-10-31T14:13:22.000Z" itemprop="datePublished">2019-10-31</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/SEED-Labs/">SEED Labs</a>
  </div>

      </div>
    

    
      
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <blockquote>
<p>参考文档：</p>
<p><a href="https://seedsecuritylabs.org/Labs_16.04/PDF/Firewall.pdf" target="_blank" rel="noopener">1.官方原文档</a></p>
<p><a href="http://www.zsythink.net/archives/1199" target="_blank" rel="noopener">2.iptables详解</a></p>
</blockquote>
<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1.Overview"></a>1.Overview</h1><p>The learning objective of this lab is for students to gain the insights（眼光，内省力） on how firewalls work by playing with firewall software and implement a simplified（简化的） packet filtering firewall. Firewalls have several types; in this lab,  we focus on <em>packet filter</em>.  Packet filters inspect（检测） packets, and decide whether to drop or forward  a packet based on firewall rules. Packet filters are usually <em>stateless</em>; they filter each packet based only on the information contained in that packet, without paying attention to whether a packet is part of an existing stream of traffic. Packet filters often use a combination（组合） of a packet’s source and destination address, its protocol, and, for TCP and UDP traffic, port numbers. In this lab, students will play with this type of firewall, and also through the implementation of some of the key functionalities, they can understand how firewalls work. Moreover, students will learn how to use SSH tunnels to bypass（绕行，撇开） firewalls. This lab covers the following topics:</p>
<p>本次实验的学习目标是让学生通过接触防火墙软件与实现一个简单的包过滤防火墙，以深入理解防火墙的工作原理。防火墙有几种类型；在本次实验中，我们关注于<em>包过滤防火墙</em>。包过滤器检测数据包，并且基于防火墙规则来决定是丢弃或是转发一个数据包。包过滤器通常来说是<em>无状态的</em>；它们仅基于数据包中包含的信息来过滤每一个数据包，而不关注数据包是否是现有业务流中的一部分。包过滤器经常组合使用一个数据包的源目地址，协议类型，及TCP和UDP流量的端口号。本实验中，学生将接触该类型防火墙，并且实现部分关键功能，他们能理解防火墙是如何工作的。此外，学生将学习如何使用SSH隧道来绕过防火墙。该实验覆盖以下主题：</p>
<ul>
<li><p>Firewall（防火墙）</p>
</li>
<li><p>Netfilter</p>
</li>
<li><p>Loadable kernel module（可加载的内核模块）</p>
</li>
<li><p>SSH tunnel（SSH隧道）</p>
<a id="more"></a>

</li>
</ul>
<p><strong>Readings and related topics.</strong> Detailed coverage of Firewalls can be found in Chapter 14 of the SEED book, <em>Computer Security: A Hands-on Approach</em>, by Wenliang Du. A related lab is the Firewall Bypassing lab, which shows how to use VPN to bypass firewalls.</p>
<p><strong>阅读及其相关主题。</strong>在杜文亮教授的SEED书籍<em>Computer Security: A Hands-on Approach</em>中的14章可以找到关于防火墙的细节。相关实验是防火墙绕行实验，该实验展示了如何使用VPN绕过防火墙。</p>
<p><strong>Lab environment.</strong> This lab has been tested on our pre-built Ubuntu 16.04 VM, which can be downloaded from the SEED website.</p>
<p><strong>实验环境。</strong>该实验已经在预建的Ubuntu 16.04 VM上通过测试，该VM可以在SEED网页上下载。</p>
<br>

<h1 id="2-Lab-Tasks实验组"><a href="#2-Lab-Tasks实验组" class="headerlink" title="2. Lab Tasks实验组"></a>2. Lab Tasks实验组</h1><h2 id="2-1-Task-1-Using-Firewall"><a href="#2-1-Task-1-Using-Firewall" class="headerlink" title="2.1 Task 1: Using Firewall"></a>2.1 Task 1: Using Firewall</h2><p><strong>2.1 实验1：使用防火墙</strong></p>
<p><em>Linux</em> has a tool called <em>iptables</em>, which is essentially(实质上) a firewall. It has a nice front end program called <em>ufw</em>. In this task, the objective is to use <em>ufw</em> to set up some firewall policies, and observe the behaviors of your system after the policies become effective. You need to set up at least two VMs, one called Machine A, and other called Machine B. You run the firewall on your Machine A. Basically, we use <em>ufw</em> as a personal firewall.  Optionally,  if you have  more VMs,  you can set up a firewall at your router,  so it can protect   a network, instead of just one single computer. After you set up the two VMs, you should perform the following tasks:</p>
<p><em>Linux</em>有个工具叫<em>iptables</em>，它实质上是个防火墙。它有个很好的前端程序，叫<em>ufw</em>。在该任务中，目标是使用<em>ufw</em>来设置一些防火墙策略，并且在策略生效后观测你系统的行为。你需要设置至少2个VM，一个叫做机器A，而另一个叫做机器B。你在你的机器A上运行防火墙。基本上，我们使用<em>ufw</em>作为一个私人防火墙。（可选），如果你有多个VM，你可以在你的路由器上设置一个防火墙，那么它可以保护你的网络，而不仅仅是一台主机。在你设置了2台VM后，你需要执行以下任务：</p>
<ul>
<li><p>Prevent A from doing telnet to Machine B.</p>
<p>阻止来自A向B的telnet访问。</p>
</li>
<li><p>Prevent B from doing telnet to Machine A.</p>
<p>阻止来自B向A的telnet访问。</p>
</li>
<li><p>Prevent A from visiting an external（外部的） web site. You can choose any web site that you like to block, but keep in mind, some web servers have multiple IP addresses.</p>
<p>阻止A访问外部的站点。你可以选择任何一个你想要禁止的网站，但是记住，一些网站有多个IP地址。</p>
</li>
</ul>
<p>You can find the manual of ufw by typing “man ufw” or search it online. It is pretty straightforward to use.  Please remember that the firewall is not enabled by default, so you should run a command to specifically（明确的） enable it. We list some commonly used commands in Appendix A.</p>
<p>你可以通过输入“man ufw”来获取ufw的手册，或是在网络上搜索它。这是最直白的使用方式。需要注意的是，防火墙默认是没有开启的，所以你需要通过使用命令来明确开启它。我们在附录A中列出了一些经常被使用的命令。</p>
<p>Before starting the task, go to the default policy file <code>/etc/default/ufw</code>. find the following entry, and change the rule from DROP to ACCEPT; otherwise, all the incoming traffic will be dropped by default.</p>
<p>在开始任务之前，找到默认的策略文件夹<code>/etc/default/ufw</code>。找到以下条目，然后把规则从DROP改为ACCEPT；此外，默认情况下的所有流入数据将会被丢弃。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set the default input policy to ACCEPT, DROP, or REJECT. Please note that if </span></span><br><span class="line"><span class="comment"># you change this you will most likely want to adjust your rules.</span></span><br><span class="line">DEFAULT_INPUT_POLICY=<span class="string">"DROP"</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="2-2-Task-2-Implementing-a-Simple-Firewall"><a href="#2-2-Task-2-Implementing-a-Simple-Firewall" class="headerlink" title="2.2 Task 2:Implementing a Simple Firewall"></a>2.2 Task 2:Implementing a Simple Firewall</h2><p><strong>任务2：实现一个简单防火墙</strong></p>
<p>The firewall you used in the previous task is a packet filtering type of firewall. The main part of this type of firewall is the filtering part, which inspects each incoming and outgoing packets, and enforces（强制执行） the firewall policies set by the administrator. Since the packet processing is done within the kernel, the filtering must also be done within the kernel. Therefore, it seems that implementing such a firewall requires us to modify the Linux kernel. In the past, this had to be done by modifying and rebuilding the kernel. The modern Linux operating systems provide several new mechanisms（机制） to facilitate（促进） the manipulation of packets without rebuilding the kernel image. These two mechanisms are <em>Loadable Kernel Module</em> (LKM) and <em>Netfilter</em>.</p>
<p>你在上一个任务中用到的防火墙是包过滤型防火墙。该类型防火墙的主要部分是过滤部分，它检测每一个流入与流出的数据包，并且强制执行防火墙上管理员所做的策略。由于包处理是在内核中完成，所以过滤也需要在内核中完成。因此，看上去似乎实现这类防火墙就要求我们去修改Linux的内核。在过去，修改和重建内核是必须要做的事情。现代Linux操作系统提供多种新的机制来促进数据包的操作，而无需重建内核镜像。以下有2种机制：<em>Loadable Kernel Module</em> (LKM) 和 <em>Netfilter</em>。</p>
<p>LKM allows us to add a new module to the kernel at the runtime. This new module enables us to extend the functionalities of the kernel, without rebuilding the kernel or even rebooting the computer. The packet filtering part of a firewall can be implemented as an LKM. However, this is not enough. In order for the filtering module to block incoming/outgoing packets, the module must be inserted into the packet processing path. This cannot be easily done in the past before the Netfilter was introduced into the Linux.</p>
<p>LKM允许我们在运行期间给内核添加一个新的模块。这种新的模块使我们能扩展内核功能，而无需重建核心甚至是重启电脑。作为LKM中防火墙的包过滤部分是可以被实现的。然而，这还不够。为了使过滤模块能够阻止传入/传出的数据包，必须将模块插入到数据包处理路径中。在以前还没有在Linux中引入Netfilter时，这可不容易实现。</p>
<p>Netfilter is designed to facilitate the manipulation of packets by authorized（合法） users. Netfilter achieves this goal by implementing a number of <em>hooks</em> in the Linux kernel. These hooks are inserted into various places, including the packet incoming and outgoing paths. If we want to manipulate the incoming packets, we simply need to connect our own programs (within LKM) to the corresponding（相应的） hooks. Once an incoming packet arrives, our program will be invoked. Our program can decide whether this packet should be blocked or not; moreover, we can also modify the packets in the program.</p>
<p>Netfilter旨在促进授权用户对数据包的操作。Netfilter通过在Linux内核中实现许多<em>hooks</em>来实现此目标。这些钩子被插入到多个地点，包括数据包流入与流出的路径。如果我们想操作流入的数据包，我们只需要连接我们的程序（在LKM内）到相应的钩子上即可。当一个流入数据包到达，我们的程序将被唤醒。我们的程序可以决定这个数据包是否该被阻止或是放行；此外，我们还可以在程序中修改数据包。</p>
<p>In this task, you need to use LKM and Netfilter to implement the packet filtering module. This module will fetch（获取） the firewall policies from a data structure, and use the policies to decide whether packets should be blocked or not. To make your life easier, so you can focus on the filtering part, the core of firewalls, we allow you to hardcode your firewall policies in the program. You should support at least five different rules, including the ones specified in the previous task. Guidelines on how to use Netfilter can be found in Section 3. In addition, Chapter 14 (§14.4) of the SEED book provides more detailed explanation on Netfilter.</p>
<p>在该任务中，你需要使用LKM和Netfilter来实现包过滤模块。该模块将从数据结构中获取防火墙策略，并且使用策略来决定数据包是否该被阻止。为了让你生活更轻松，你可以只关注过滤部分，这是防火墙的核心，我们允许你在程序中硬编码你的防火墙策略。你应该支持至少5个不同的规则，包括上一个任务指定的规则。有关如何使用Netfilter的指南，请参见第3节。此外，SEED手册的第14章（第14.4节）提供了有关Netfilter的更详细说明。</p>
<p><strong>Note for Ubuntu 16.04 VM:</strong>   The code in the SEED book was developed in Ubuntu 12.04.   It needs to be changed slightly to work in Ubuntu 16.04.  The change is in the definition of the callback function <em>telnetFilter()</em>, because the prototype of Netfilter’s callback function has been changed in Ubuntu 16.04. See the difference in the following:</p>
<p><strong>对于Ubuntu 16.04 VM的注意事项：</strong>SEED书中的代码是在Ubuntu 12.04中开发的。 需要稍作更改才能在Ubuntu 16.04中工作。 更改是在回调函数<em>telnetFilter（）</em>的定义中进行的，因为Netfilter的回调函数的原型已在Ubuntu 16.04中进行了更改。 请参阅以下内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// In Ubuntu <span class="number">12.04</span></span><br><span class="line">unsigned int telnetFilter(unsigned int hooknum, struct sk_buff *skb, </span><br><span class="line">                          const struct net_device *<span class="keyword">in</span>, const struct net_device *out, </span><br><span class="line">                          int (*okfn)(struct sk_buff *))</span><br><span class="line"></span><br><span class="line">// In Ubuntu <span class="number">16.04</span></span><br><span class="line">unsigned int telnetFilter(void *priv, struct sk_buff *skb,</span><br><span class="line">                          const struct nf_hook_state *state)</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://dilidonglong.site/2019/10/31/Linux防火墙探索实验/" data-id="ck2etvjcp0003wcvdpsaawddh"
         class="article-share-link">分享</a>
      
    </footer>

  </div>

  
    
  <nav class="article-nav">
    
    
      <a href="/2019/10/23/电脑开启系统无线功能/" class="article-nav-link">
        <strong class="article-nav-caption">后一篇</strong>
        <div class="article-nav-title">电脑开启系统无线功能</div>
      </a>
    
  </nav>


  

  
    
  <div class="gitalk" id="gitalk-container"></div>
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: '15c18d9b0a015598eb07',
      clientSecret: 'a3853e070f5ab7e4de32abbdda82175936eab5cf',
      repo: 'gitalk',
      owner: 'dilidonglong',
      admin: ['dilidonglong'],
      // id: location.pathname,      // Ensure uniqueness and length less than 50
      id: md5(location.pathname),
      distractionFreeMode: false,  // Facebook-like distraction free mode
      pagerDirection: 'last'
    })

  gitalk.render('gitalk-container')
  </script>

  

</article>



</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2019 望伊如西の博客</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>

<aside class="sidebar sidebar-specter">
  
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="望伊如西の博客"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">主页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">相册</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/categories">分类</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/tocbot.min.js"></script>
  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>

<script src="/js/ocean.js"></script>
</body>
</html>